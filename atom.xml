<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nummy</title>
  <subtitle>Less is more</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nummy.github.io/"/>
  <updated>2016-09-06T12:57:38.139Z</updated>
  <id>http://nummy.github.io/</id>
  
  <author>
    <name>Nummy Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>scala inheritance</title>
    <link href="http://nummy.github.io/2016/09/06/scala-inheritance/"/>
    <id>http://nummy.github.io/2016/09/06/scala-inheritance/</id>
    <published>2016-09-06T12:57:16.000Z</published>
    <updated>2016-09-06T12:57:38.139Z</updated>
    
    <content type="html"><![CDATA[<h3 id="扩展类"><a href="#扩展类" class="headerlink" title="扩展类"></a>扩展类</h3><p>scala扩展类的方式和Java一样，使用extends关键字：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</div><div class="line">    <span class="keyword">val</span> salary = <span class="number">0.0</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>和Java一样，你可以将类声明为final，这样它就不能被扩展。你可以将单个方法或者字段声明为final， 以确保它们不能够被重写。</p>
<h3 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h3><p>在scala中重写一个非抽象方法必须使用override修饰符。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= getClass.getName + <span class="string">"[name="</span> + name + <span class="string">"]"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>override修饰符可以用在多个情况下给出有用的错误提示。包括：</p>
<ul>
<li>当你拼错要重写的方法名</li>
<li>当你不小心在新方法中使用错误的参数类型。</li>
<li>当你在超类中引入新的方法，而这个新的方法与子类的方法相抵触。</li>
</ul>
<p>在scala中调用超类的方法和Java一样，使用super关键字。</p>
<h3 id="类型转换和检查"><a href="#类型转换和检查" class="headerlink" title="类型转换和检查"></a>类型转换和检查</h3><p>要检查某个对象是否属于某个特定的类，可以用isInstanceOf方法。如果测试成功，你就可以使用asInstanceOf方法将引用转换为子类的引用。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (p.isInstanceOf[<span class="type">Employee</span>])&#123;</div><div class="line">    <span class="keyword">val</span> s = p.asInstanceOf[<span class="type">Employee</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果p指向的是Employee类及其子类，则p.isInstanceOf[Employee]就会成功；</p>
<p>如果p是null， 则p.isInstanceOf[Employee]将返回false，且p.asInstanceOf[Employee]将返回null。</p>
<p>如果p不是一个Employee，则p.asInstanceOf[Employee]将抛出异常。</p>
<p>不过与类型检查和转化相比，模式匹配通常是更好的选择。</p>
<h3 id="受保护字段"><a href="#受保护字段" class="headerlink" title="受保护字段"></a>受保护字段</h3><p>如果字段或方法被声明为protected，则这样的成员可以被任何子类访问，但不能从其他位置看到。与Java不同的是，protected的成员对于类所属的包而言，是不可见的。</p>
<h3 id="超类的构造"><a href="#超类的构造" class="headerlink" title="超类的构造"></a>超类的构造</h3><p>辅助构造器永远不能够直接调用超类的构造器，子类的辅助构造器最终都会调用主构造器，只有主构造器可以调用超类的构造器。</p>
<p>scala类可以扩展Java类，这种情况下，它的主构造器必须调用Java超类的某一个构造方法。</p>
<h3 id="重写字段"><a href="#重写字段" class="headerlink" title="重写字段"></a>重写字段</h3><p>注意以下限制：</p>
<ul>
<li>def只能重写另一个def</li>
<li>val只能重写另一个val或不带参数的def</li>
<li>var只能重写另一个抽象的var</li>
</ul>
<h3 id="匿名子类"><a href="#匿名子类" class="headerlink" title="匿名子类"></a>匿名子类</h3><p>和Java一样，你可以通过包含带有定义或者重写代码块的方式创建一个匿名子类。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> align = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Fred"</span>)&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greeting</span> </span>= <span class="string">"hello"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>和Java一样，可以使用abstract关键字定义一个不能被实例化的类。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name:<span class="type">String</span></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">id</span></span>:<span class="type">Int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是在scala中，不像java，你不需要对抽象方法使用abstract关键字，你只是省去方法体。</p>
<p>在子类中重写父类的抽象方法时，你不需要使用override关键字。</p>
<h3 id="抽象字段"><a href="#抽象字段" class="headerlink" title="抽象字段"></a>抽象字段</h3><p>除了抽象方法之外，类还可以拥有抽象字段，抽象字段就是一个没有初始化值的字段。</p>
<p>具体的子类必须提供具体的字段。和方法一样，在子类中重写超类的抽象字段时，不需要override关键字。</p>
<h3 id="scala继承层级"><a href="#scala继承层级" class="headerlink" title="scala继承层级"></a>scala继承层级</h3><p>所有其他类都是AnyRef的子类，AnyRef相当于Java中的Object类。</p>
<p>AnyVal和AnyRef都扩展自Any类，而Any类是整个继承层级的根节点。</p>
<p>Null类型的唯一实例就是null值，你可以额将null值赋值给任何引用，但不能赋值给值类型的应用。</p>
<p>Nothing类型没有实例，它对于泛型结构时常有用。</p>
<h3 id="对象相等性"><a href="#对象相等性" class="headerlink" title="对象相等性"></a>对象相等性</h3><p>在scala中，AnyRef的eq方法检查两个引用是否指向同一个对象。AnyRef的equals方法调用eq。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;扩展类&quot;&gt;&lt;a href=&quot;#扩展类&quot; class=&quot;headerlink&quot; title=&quot;扩展类&quot;&gt;&lt;/a&gt;扩展类&lt;/h3&gt;&lt;p&gt;scala扩展类的方式和Java一样，使用extends关键字：&lt;br&gt;&lt;figure class=&quot;highlight scala
    
    </summary>
    
      <category term="scala" scheme="http://nummy.github.io/categories/scala/"/>
    
    
      <category term="scala" scheme="http://nummy.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>scala学习笔记【7】包和引入</title>
    <link href="http://nummy.github.io/2016/09/06/scala-package/"/>
    <id>http://nummy.github.io/2016/09/06/scala-package/</id>
    <published>2016-09-06T12:56:10.000Z</published>
    <updated>2016-09-06T12:56:50.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>scala的包目的和Java中的包一样：管理大型程序中的名称。</p>
<p>要增加条目到包中，可以将其包含在包语句中，例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com&#123;</div><div class="line">    <span class="keyword">package</span> horstman &#123;</div><div class="line">        <span class="keyword">package</span> patient&#123;</div><div class="line">            <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</div><div class="line">            ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样一来，类名Employee就可以在任意位置以com.horstman.patient.Employee访问了。</p>
<p>与对象和类的定义不同，同一个包可以定义在多个文件中。</p>
<p>源文件的目录和包之间并没有强制的关联关系，也就是说可以在同一个文件中定义多个包。</p>
<h3 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h3><p>在scala中，包的作用域比Java更加前后一致，scala的包和其他作用域一样支持嵌套。可以访问上层作用域中的名称。</p>
<p>在Java中包名是绝对的，从包层级的最顶端开始，但是在scala中，包名是相对的，就像内部类的名称一样。</p>
<h3 id="串联式包语句"><a href="#串联式包语句" class="headerlink" title="串联式包语句"></a>串联式包语句</h3><p>包语句可以包含一个串，或者说路径区段：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.hosrtman.patient&#123;</div><div class="line">    <span class="keyword">package</span> people&#123;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这条语句限制了可见的成员。</p>
<h3 id="文件顶部标识法"><a href="#文件顶部标识法" class="headerlink" title="文件顶部标识法"></a>文件顶部标识法</h3><p>除了使用嵌套标记法之外，还可以在文件顶部使用package语句，不带花括号。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.hosrtman.people.patient</div><div class="line"><span class="keyword">package</span> people</div></pre></td></tr></table></figure></p>
<h3 id="包对象"><a href="#包对象" class="headerlink" title="包对象"></a>包对象</h3><p>包可以包含类，对象和特质，但是不能包含函数和变量的定义。</p>
<p>每个包可以有一个包对象，你需要在父包中定义它，且名称和子包一样。<br>例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.horstman.patient</div><div class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">people</span></span>&#123;</div><div class="line">    <span class="keyword">val</span> defaultName = <span class="string">"John"</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">package</span> people&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">        <span class="keyword">val</span> name = defaultName  <span class="comment">//从包对象中拿到常量</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="包可见性"><a href="#包可见性" class="headerlink" title="包可见性"></a>包可见性</h3><p>在Java中，没有被声明为public、private或protected的类成员在包含该类的包中可见。在scala中，可以通过修饰符达到同样的目的。</p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>引入语句可以让你使用更短的名字而不是原来较长的名字。<br>写法如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.<span class="type">Color</span></div></pre></td></tr></table></figure></p>
<p>引入包中全部成员：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt._</div></pre></td></tr></table></figure></p>
<h3 id="任何地方都可以声明引入"><a href="#任何地方都可以声明引入" class="headerlink" title="任何地方都可以声明引入"></a>任何地方都可以声明引入</h3><p>在scala中，import语句可以出现在任意地方，并不仅限于文件顶部，import语句的效果一直延伸到包含该语句的块末尾。</p>
<h3 id="重命名和隐藏"><a href="#重命名和隐藏" class="headerlink" title="重命名和隐藏"></a>重命名和隐藏</h3><p>如果你想引入包中的几个成员，可以像这样使用选取器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.&#123;<span class="type">Color</span>, <span class="type">Font</span>&#125;</div></pre></td></tr></table></figure></p>
<p>选取器还允许你重命名选到的成员：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">HashMap</span> =&gt; <span class="type">JavaHashMap</span>&#125;</div></pre></td></tr></table></figure></p>
<p>选取器<code>HashMap =&gt; _</code>将隐藏某个成员而不是重命名它。</p>
<h3 id="隐式引入"><a href="#隐式引入" class="headerlink" title="隐式引入"></a>隐式引入</h3><p>每个scala程序都隐式的以如下代码开始：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang._</div><div class="line"><span class="keyword">import</span> scala._</div><div class="line"><span class="keyword">import</span> <span class="type">Predef</span>._</div></pre></td></tr></table></figure></p>
<p>由于scala包默认导入，对于那些以scala开头的包，你完全不需要写全这个前缀。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;包&quot;&gt;&lt;a href=&quot;#包&quot; class=&quot;headerlink&quot; title=&quot;包&quot;&gt;&lt;/a&gt;包&lt;/h3&gt;&lt;p&gt;scala的包目的和Java中的包一样：管理大型程序中的名称。&lt;/p&gt;
&lt;p&gt;要增加条目到包中，可以将其包含在包语句中，例如：&lt;br&gt;&lt;figure
    
    </summary>
    
      <category term="scala" scheme="http://nummy.github.io/categories/scala/"/>
    
    
      <category term="scala" scheme="http://nummy.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>scala学习笔记【6】对象</title>
    <link href="http://nummy.github.io/2016/09/04/scala-object/"/>
    <id>http://nummy.github.io/2016/09/04/scala-object/</id>
    <published>2016-09-04T01:15:45.000Z</published>
    <updated>2016-09-04T01:17:41.580Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h3><p>scala中没有静态方法或静态字段，不过可以使用object这个语法结构来达到同样的目的。对象定义了某个类的单个实例，包含了我们想要的特性。<br>例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Accounts</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lastNumber = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newUniqueNumber</span></span>() = &#123;lastNumber += <span class="number">1</span>; lastNumber &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对象的构造器在第一次使用时被调用，如果一个对象从未被使用，那么其构造器也不会被执行。</p>
<p>对象本质上可以拥有类的所有特性，它甚至可以扩展其他类和特质，只有一个例外，不能提供构造参数。</p>
<p>对于任何你在Java中会使用单例对象的地方，在Scala中都可以用对象实现：</p>
<ul>
<li>作为存放工具函数和常量的地方</li>
<li>高效的共享单个不可变实例</li>
<li>需要用单个实例来协调某个服务时。</li>
</ul>
<h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>在Java中，通常会用到既有实例方法又有静态方法的类，在类中，可以通过类和与类同名的伴生对象来实现。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accounts</span> </span>&#123;</div><div class="line">    <span class="keyword">val</span> id = <span class="type">Accounts</span>.newUniqueNumber()</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> balance = <span class="number">0.0</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">despoit</span></span>(amount:<span class="type">Double</span>)&#123;balance += amount&#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Accounts</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lastNumber = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newUniqueNumber</span></span>() = &#123;lastNumber += <span class="number">1</span>; lastNumber &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>类和它的伴生对象可以互相访问私有特性，它们必须存在于同一个源文件中。</p>
<p>类的伴生对象可以被访问，但是并不在作用域中。</p>
<h3 id="扩展类或特质的对象"><a href="#扩展类或特质的对象" class="headerlink" title="扩展类或特质的对象"></a>扩展类或特质的对象</h3><p>一个对象可以扩展类以及一个或者多个特质，其结果是一个扩展了指定类以及特质的类的对象，同时拥有在对象定义中给出的所有特性。</p>
<p>一个有用的场景是给出可被共享的缺省对象。</p>
<h3 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h3><p>我们通常会定义和使用对象的方法，当遇到如下形式的表达式时，apply方法就会被调用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Object</span>(arg1, ..., argN)</div></pre></td></tr></table></figure></p>
<p>通常这样一个apply方法返回的是伴生类的对象。</p>
<h3 id="应用程序对象"><a href="#应用程序对象" class="headerlink" title="应用程序对象"></a>应用程序对象</h3><p>每个scala程序都必须从一个对象的main方法开始，这个方法的类型为<code>Array[String]=&gt;Unit</code>:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Hello</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>])&#123;</div><div class="line">        println(<span class="string">"hello,world"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除了每次都提供自己的main方法之外，我们还可以扩展App特质，然后将程序代码放到构造器方法体中：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">APP</span> </span>&#123;</div><div class="line">    println(<span class="string">"hello,world"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果需要命令行参数，可以通过args属性获取。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>和Java不同，scala并没有枚举类型，不过标准类库提供了一个Enumeration助手类，可以用于产生枚举。</p>
<p>定义一个扩展Enumeration类的对象并以Value方法调用初始化枚举中的所有可选值。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">TrafficLightColor</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>&#123;</div><div class="line">    <span class="keyword">val</span> <span class="type">Red</span>, <span class="type">Yellow</span>, <span class="type">Green</span> = <span class="type">Value</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里定义了三个字段：Red, Yeelow, Green。然后调用Value方法进行初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val Red = Value</div><div class="line">val Yellow 　= Value</div><div class="line">val Green = Green</div></pre></td></tr></table></figure></p>
<p>每次调用Value方法都返回内部类的新实例，该内部类也叫Value。<br>或者，也可以向Value方法传递ID、名称，或两个参数都传。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> <span class="type">Red</span> = <span class="type">Value</span>(<span class="number">0</span>, <span class="string">"Stop"</span>)</div><div class="line"><span class="keyword">val</span> <span class="type">Yellow</span> = <span class="type">Value</span>(<span class="number">10</span>)</div><div class="line"><span class="keyword">val</span> <span class="type">Green</span> = <span class="type">Value</span>(<span class="string">"Go"</span>)</div></pre></td></tr></table></figure></p>
<p>如果不指定，则ID将在前一个枚举值的基础上加一， 从零开始，缺省名称为字段名。</p>
<p>定义完成之后，就可以使用TrafficLightColor.Red、TrafficLightCOlor.Yellow等来引用枚举值了。</p>
<p>枚举值的ID可以通过id方法返回，名称通过toString方法返回。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单例对象&quot;&gt;&lt;a href=&quot;#单例对象&quot; class=&quot;headerlink&quot; title=&quot;单例对象&quot;&gt;&lt;/a&gt;单例对象&lt;/h3&gt;&lt;p&gt;scala中没有静态方法或静态字段，不过可以使用object这个语法结构来达到同样的目的。对象定义了某个类的单个实例，包含了
    
    </summary>
    
      <category term="scala" scheme="http://nummy.github.io/categories/scala/"/>
    
    
      <category term="scala" scheme="http://nummy.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>scala学习笔记【5】类</title>
    <link href="http://nummy.github.io/2016/09/03/scala-class/"/>
    <id>http://nummy.github.io/2016/09/03/scala-class/</id>
    <published>2016-09-03T13:19:39.000Z</published>
    <updated>2016-09-03T13:20:36.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单类和无参方法"><a href="#简单类和无参方法" class="headerlink" title="简单类和无参方法"></a>简单类和无参方法</h3><p>Scala类最简单的形式和Java相似：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value = <span class="number">0</span> <span class="comment">//必须初始化</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span></span>() &#123; value += <span class="number">1</span>&#125;   <span class="comment">//方法默认是公有的</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">current</span> </span>() = value</div></pre></td></tr></table></figure></p>
<p>在scala中，类并不声明为public，scala源文件可以包含多个类，所有这些类都具有公有可见性。</p>
<p>调用无参方法时，可以使用圆括号，也可以不使用。一般的，对于改值器方法使用(),对于取值器方法则去掉()。</p>
<p>也可以使用不带()的方式声明current来强制调用的时候不使用()。</p>
<h3 id="带有getter和setter的属性"><a href="#带有getter和setter的属性" class="headerlink" title="带有getter和setter的属性"></a>带有getter和setter的属性</h3><p>Scala对每一个字段都提供了getter和setter方法。这里定义一个公有字段：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Scala生成面向JVM的类，其中有一个私有的age字段以及相应的getter和setter方法。这两个方法是公有的，因为我们没有将age声明为private。对于私有字段而言，getter和setter也是私有的。</p>
<p>在scala中，getter和setter分别叫做age和age_=。<br>例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">println(fred.age)</div><div class="line">fred.age = <span class="number">20</span></div></pre></td></tr></table></figure></p>
<p>在任何时候你都可以自己重新定义getter和setter方法。</p>
<p>如果字段是val，则只有getter方法被生成。如果你不需要任何getter和setter，可以将字段声明为private[this]。</p>
<p>###只带getter的属性</p>
<p>是用val字段，scala会生成一个final字段和一个getter方法。</p>
<h3 id="对象私有字段"><a href="#对象私有字段" class="headerlink" title="对象私有字段"></a>对象私有字段</h3><p>在scala中，方法可以访问该类的所有对象的私有字段。scala允许我们定义更加严格的访问限制，通过private[this]这个修饰符实现。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> value = <span class="number">0</span> <span class="comment">//类似某个对象.value这样的访问将不被允许</span></div></pre></td></tr></table></figure></p>
<p>这样的访问有时候称之为对象私有的。</p>
<p>对于类私有的字段，scala会生成私有的getter和setter方法，但对于对象私有的字段，scala根本不会生成getter和setter方法。</p>
<p>scala允许将访问权赋予给指定的类，private[类名]修饰符可以定义仅有指定类的方法可以访问给定的字段。这里的类必须是当前定义的类，或者是包含该类的外部类。</p>
<h3 id="辅助构造器"><a href="#辅助构造器" class="headerlink" title="辅助构造器"></a>辅助构造器</h3><p>和Java一样，Scala也可以有任意多的构造器，包括主构造器与辅助构造器。</p>
<p>辅助构造器与Java的构造器类似，只有两处不同：</p>
<ul>
<li>辅助构造器的名称为this</li>
<li>每一个辅助构造器都必须以一个对先前已定义的的其他辅助构造器或主构造器的调用开始。</li>
</ul>
<p>下面的类中包含两个辅助构造器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name = <span class="string">""</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> age = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name:<span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">this</span>()</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name:<span class="type">String</span>, age:<span class="type">Int</span>)&#123;</div><div class="line">        <span class="keyword">this</span>(name)</div><div class="line">        <span class="keyword">this</span>.age = age</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个类如果没有显示定义主构造器则自动拥有一个无参的主构造器。<br>现在，我们可以使用三种方式构建对象：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> p1 = <span class="type">Person</span></div><div class="line"><span class="keyword">val</span> p2 = <span class="type">Person</span>(<span class="string">"Jim"</span>)</div><div class="line"><span class="keyword">val</span> p3 = <span class="type">Person</span>(<span class="string">"Jim"</span>,<span class="number">12</span>）</div></pre></td></tr></table></figure></p>
<h3 id="主构造器"><a href="#主构造器" class="headerlink" title="主构造器"></a>主构造器</h3><p>在scala中，每个类都有主构造器，主构造器并不以this方法定义，而与类定义交织在一起。</p>
<ol>
<li>主构造器的参数直接放置在类名之后。</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name:<span class="type">String</span>, val age:<span class="type">Int</span></span>)</span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主构造器的参数被编译成字段，其值被初始化成构造时传入的参数。</p>
<ol>
<li>主构造器会执行类定义中的所有字段。例如:</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name:<span class="type">String</span>, val age:<span class="type">Int</span></span>)</span>&#123;</div><div class="line">    println(<span class="string">"Just constructed another person"</span>)</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>println语句是主构造器的一部分，每当有对象被构造出来的时候，上述代码就会被执行。当你I需要再构造过程中配置某个字段的时候这个特性特别有用。</p>
<p>如果类名之后没有参数，则该类具备一个无参主构造器，这样的一个构造器仅仅简单的执行类体中的所有语句而已。</p>
<p>构造函数也可以是普通的方法参数，不带val或var。这样的参数如何处理取决于它在类中如何被使用。</p>
<ul>
<li>如果不带val或者var参数至少被一个方法所使用，它将被升格为字段。例如：<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name:<span class="type">String</span>, age:<span class="type">Int</span></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">description</span> </span>= name + <span class="string">" is "</span> + age + <span class="string">" years old"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上述代码声明并初始化了不可变字段的name和age。而这两个字段都是对象私有化的。类似这样的字段等同于private[this] val字段的效果。</p>
<ul>
<li>否则，该参数将不被保存为字段，它仅仅是一个可以被主构造器中的代码访问的普通参数表。</li>
</ul>
<p>如果想让主构造器变成私有的，可以像这样放置private关键字。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">private</span> (<span class="params">val id:<span class="type">Int</span></span>)</span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样一来，用户就必须通过辅助构造器来构造Person对象了。</p>
<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>在scala中，你几乎可以在任何语法结构中内嵌任何语法结构，你可以在函数中定义函数，也可以在类中定义类。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简单类和无参方法&quot;&gt;&lt;a href=&quot;#简单类和无参方法&quot; class=&quot;headerlink&quot; title=&quot;简单类和无参方法&quot;&gt;&lt;/a&gt;简单类和无参方法&lt;/h3&gt;&lt;p&gt;Scala类最简单的形式和Java相似：&lt;br&gt;&lt;figure class=&quot;highlig
    
    </summary>
    
      <category term="scala" scheme="http://nummy.github.io/categories/scala/"/>
    
    
      <category term="scala" scheme="http://nummy.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>scala学习笔记【4】映射和元组</title>
    <link href="http://nummy.github.io/2016/09/03/scala-map-and-tuple/"/>
    <id>http://nummy.github.io/2016/09/03/scala-map-and-tuple/</id>
    <published>2016-09-03T08:48:43.000Z</published>
    <updated>2016-09-03T08:49:29.662Z</updated>
    
    <content type="html"><![CDATA[<h3 id="构造映射"><a href="#构造映射" class="headerlink" title="构造映射"></a>构造映射</h3><p>不可变映射<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> score = <span class="type">Map</span>(<span class="string">"Alice"</span>-&gt;<span class="number">80</span>)</div></pre></td></tr></table></figure></p>
<p>可变映射<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> score = scala.collection.mutable.<span class="type">Map</span>(<span class="string">"Alice"</span><span class="number">-90</span>)</div></pre></td></tr></table></figure></p>
<p>在scala中，映射是一个对偶，对偶是两个值构成的组，这两个值不一定是同一类型。</p>
<p>使用<code>-&gt;</code>来创建对偶。</p>
<h3 id="获取映射的值"><a href="#获取映射的值" class="headerlink" title="获取映射的值"></a>获取映射的值</h3><p>在scala中使用()表示法来查找某个键对应的值。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> bobscore = scores(<span class="string">"Bob"</span>)</div></pre></td></tr></table></figure></p>
<p>如果映射并不包含请求中使用的键，则会抛出异常。<br>要检查映射中是否有某个指定的键，可以使用contains方法。</p>
<p>除此之外，我们还可以使用getOrElse方法。</p>
<h3 id="更新映射中的值"><a href="#更新映射中的值" class="headerlink" title="更新映射中的值"></a>更新映射中的值</h3><p>在可变映射中，可以更新映射值，做法是在=的左侧使用()。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scores(<span class="string">"Bob"</span>) = <span class="number">10</span></div></pre></td></tr></table></figure></p>
<p>也可以使用 += 来添加多个关系：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scores +=  (<span class="string">"Kate"</span> -&gt; <span class="number">80</span>)</div></pre></td></tr></table></figure></p>
<p>使用-=移除某个键和对应的值。</p>
<h3 id="迭代映射"><a href="#迭代映射" class="headerlink" title="迭代映射"></a>迭代映射</h3><p>使用for循环遍历映射中所有的键：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( (k, v) &lt;- map)</div></pre></td></tr></table></figure></p>
<p>访问键或者值：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scores.keySet</div><div class="line">scores.values</div></pre></td></tr></table></figure></p>
<p>反转映射<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( (k, v) &lt;- map) <span class="keyword">yield</span> (v, k)</div></pre></td></tr></table></figure></p>
<h3 id="已排序映射"><a href="#已排序映射" class="headerlink" title="已排序映射"></a>已排序映射</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> scores = scala.collections.immutable.<span class="type">SortedMap</span>(<span class="string">"A"</span>-&gt;<span class="number">1</span>, <span class="string">"B"</span>-&gt;<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>如果需要按插入顺序访问所有键的话，使用LinkedHashMap。</p>
<p>###　元组<br>元组是不同类型值的集合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val t = (1, &quot;a&quot;, 3.14)</div></pre></td></tr></table></figure></p>
<p>和数组或字符串中的位置不同，元组从1开始而不是0。</p>
<p>通常，使用模式匹配来获取元组的组员。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> (first , second, third ) = t</div></pre></td></tr></table></figure></p>
<p>如果并不是所有的部件都需要，则可以在不需要的位置使用_。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> (first, second, _) =  t</div></pre></td></tr></table></figure></p>
<h3 id="拉链操作"><a href="#拉链操作" class="headerlink" title="拉链操作"></a>拉链操作</h3><p>使用元组的原因之一是多个值绑定在一起，以便它们能够一起被处理，这通常可以用zip方法实现。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> symbols = <span class="type">Array</span>(<span class="string">"&lt;"</span>,<span class="string">"-"</span>, <span class="string">"&gt;"</span>)</div><div class="line"><span class="keyword">val</span> counts = <span class="type">Array</span>(<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>)</div><div class="line"><span class="keyword">val</span> paris = symbols.zip(counts)</div></pre></td></tr></table></figure></p>
<p>输出对偶的数组：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Array</span>((<span class="string">"&lt;"</span>,<span class="number">2</span>),(<span class="string">"-"</span>,<span class="number">10</span>),(<span class="string">"&gt;"</span>,<span class="number">2</span>))</div></pre></td></tr></table></figure></p>
<p>使用toMap可以将对偶的集合转换成映射。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;构造映射&quot;&gt;&lt;a href=&quot;#构造映射&quot; class=&quot;headerlink&quot; title=&quot;构造映射&quot;&gt;&lt;/a&gt;构造映射&lt;/h3&gt;&lt;p&gt;不可变映射&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
    
    </summary>
    
      <category term="scala" scheme="http://nummy.github.io/categories/scala/"/>
    
    
      <category term="scala" scheme="http://nummy.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>scala学习笔记【3】数组</title>
    <link href="http://nummy.github.io/2016/09/03/scala-array/"/>
    <id>http://nummy.github.io/2016/09/03/scala-array/</id>
    <published>2016-09-03T07:52:20.000Z</published>
    <updated>2016-09-03T08:28:21.361Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h3><p>如果需要一个长度不变的数组，可以使用scala中的Array。</p>
<h3 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h3><p>变长数组使用ArrayBuffer，在数组缓存的尾端添加或者移除元素是一个高效的操作。</p>
<p>使用toArray将数组缓存转数组，使用toBuffer将数组转成缓存。</p>
<h3 id="遍历数组和数组缓存"><a href="#遍历数组和数组缓存" class="headerlink" title="遍历数组和数组缓存"></a>遍历数组和数组缓存</h3><p>使用for循环遍历数组或者缓存：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( i &lt;- <span class="number">0</span> until a.length)</div><div class="line">    println(i)</div></pre></td></tr></table></figure></p>
<p>如果想每两个元素一跳，可以这样遍历：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span> until (a.length,<span class="number">2</span>)</div></pre></td></tr></table></figure></p>
<p>如果想从数组的尾端开始，遍历写法为:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="number">0</span> until a.length).reverse</div></pre></td></tr></table></figure></p>
<h3 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h3><p>从一个数组出发，以某种方式对它进行转换，这些转换操作不会修改原数组，而是产生一个新的数组。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</div><div class="line"><span class="keyword">val</span> result = <span class="keyword">for</span>(elem &lt;- a) <span class="keyword">yield</span> <span class="number">2</span>*elem</div></pre></td></tr></table></figure></p>
<p>结果返回一个类型与原始集合相同的新集合。<br>我们也可以给转换增加过滤条件：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(elem &lt;- a <span class="keyword">if</span> elem % <span class="number">2</span> == <span class="number">0</span>） <span class="keyword">yield</span> <span class="number">2</span> * elem</div></pre></td></tr></table></figure></p>
<p>注意原始集合并没有受到影响。</p>
<p>另一种做法是：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.filter(_ % <span class="number">2</span> == <span class="number">0</span>).map(<span class="number">2</span> * _)</div></pre></td></tr></table></figure></p>
<p>甚至：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.filter&#123; _ % <span class="number">2</span> == <span class="number">0</span> &#125; map &#123;<span class="number">2</span> * _&#125;</div></pre></td></tr></table></figure></p>
<h3 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h3><p>求和<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).sum</div></pre></td></tr></table></figure></p>
<p>最小值和最大值<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).min</div><div class="line"><span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).max</div></pre></td></tr></table></figure></p>
<p>排序<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Array</span>(<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>).sorted(_ &lt; _)</div></pre></td></tr></table></figure></p>
<p>显示数组内容：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a.mkString</div><div class="line">a.mkString(<span class="string">" and "</span>)</div><div class="line">a.mkString(<span class="string">"&lt;"</span>,<span class="string">","</span>,<span class="string">"&gt;"</span>)</div></pre></td></tr></table></figure></p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> matrix = <span class="type">Array</span>.ofDim[<span class="type">Double</span>](<span class="number">3</span>,<span class="number">4</span>)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定长数组&quot;&gt;&lt;a href=&quot;#定长数组&quot; class=&quot;headerlink&quot; title=&quot;定长数组&quot;&gt;&lt;/a&gt;定长数组&lt;/h3&gt;&lt;p&gt;如果需要一个长度不变的数组，可以使用scala中的Array。&lt;/p&gt;
&lt;h3 id=&quot;变长数组&quot;&gt;&lt;a href=&quot;#变长
    
    </summary>
    
      <category term="scala" scheme="http://nummy.github.io/categories/scala/"/>
    
    
      <category term="scala" scheme="http://nummy.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>scala学习笔记【2】流程与函数</title>
    <link href="http://nummy.github.io/2016/09/03/scala-flow/"/>
    <id>http://nummy.github.io/2016/09/03/scala-flow/</id>
    <published>2016-09-03T02:59:55.000Z</published>
    <updated>2016-09-03T08:28:23.979Z</updated>
    
    <content type="html"><![CDATA[<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>scala的if/esle语法结构与Java一样，但是在scala中if/else表达式有值，这个值就是跟在if或else之后表达式的值。</p>
<p>我们可以将if/else表达式的值赋予给变量：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="keyword">if</span> (x&gt;<span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></div></pre></td></tr></table></figure></p>
<p>它等价于<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (x&gt;<span class="number">0</span>) s = <span class="number">1</span> <span class="keyword">else</span> s = <span class="number">-1</span></div></pre></td></tr></table></figure></p>
<p>不过，第一种写法更好，因为它可以用来初始化一个val， 而第二种写法中，s必须是var。</p>
<p>在Scala中，每个表达式都有一个类型。</p>
<p>如果是混合类型，则类型为Any。</p>
<p>如果else部分缺失，例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (x&gt;<span class="number">0</span>) <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (x&gt;<span class="number">0</span>) <span class="keyword">else</span> ()</div></pre></td></tr></table></figure></p>
<p>Scala没有switch语句，但是它有一个更强大的模式匹配机制。</p>
<h3 id="语句终止"><a href="#语句终止" class="headerlink" title="语句终止"></a>语句终止</h3><p>在scala中，分号绝大多数情况下都不是必须的。不过如果你想在单行中写下多个语句，则需要将它们以分号隔开。</p>
<h3 id="块表达式和赋值"><a href="#块表达式和赋值" class="headerlink" title="块表达式和赋值"></a>块表达式和赋值</h3><p>在Scala中，{}包含一系列表达式，块中最后一个表达式的值就是块的值。</p>
<p>在Scala中赋值语句是没有值的，所以别把它们串接在一起。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x = y = <span class="number">1</span> <span class="comment">//别这样做</span></div></pre></td></tr></table></figure></p>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><p>使用print或者println打印一个值。</p>
<p>使用printf格式化输出。</p>
<p>使用readLine从控制台读取一行输入，如果是读取数字，Boolean或者字符串，可以使用readInt, readDouble, readByte, readShort, readLong, readFloat, readBoolean或者 readChar。与其他方法不同，readLine带一个参数作为提示字符串。</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>scala支持while循环和for循环，while循环与Java的while一样，for循环语法如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( i &lt;- 表达式)</div></pre></td></tr></table></figure></p>
<p>遍历字符串和数组时，你通常需要使用0 到n-1的区间，这个时候可以使用until方法而不是to方法。until方法返回一个并不包含上限的区间。</p>
<h3 id="高级for循环和for推导式"><a href="#高级for循环和for推导式" class="headerlink" title="高级for循环和for推导式"></a>高级for循环和for推导式</h3><p>可以使用变量<code>&lt;-</code>表达式的形式提供多个生成器，用分号隔开。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for(i &lt;-1 to 3, j &lt;- 1 to 3) print ((10*i+j)+ &quot; &quot;)</div></pre></td></tr></table></figure></p>
<p>每个生成器还可以带过滤条件，以if开头的Boolean表达式。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(i &lt;<span class="number">-1</span> to <span class="number">3</span>, j &lt;- <span class="number">1</span> to <span class="number">3</span> <span class="keyword">if</span> i != j) print ((<span class="number">10</span>*i+j)+ <span class="string">" "</span>)</div></pre></td></tr></table></figure></p>
<p>还可以使用任意多的定义，引入可以在循环中使用的变量：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( i &lt;- <span class="number">1</span> to <span class="number">3</span>; from = <span class="number">4</span>-i; j &lt;- from to <span class="number">3</span>)  print ((<span class="number">10</span>*i+j)+ <span class="string">" "</span>)</div></pre></td></tr></table></figure></p>
<p>如果for循环的循环体以yield开始，则该循环会构造出一个集合，每次迭代出集合中的一个值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for( i &lt;- 1 to 10) yield i % 3</div></pre></td></tr></table></figure></p>
<p>这类循环叫做for推导式。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>要定义函数，需要给出函数的名称、参数和函数体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">def abs(x:Double) = if (x&gt;0) x else -x</div></pre></td></tr></table></figure></p>
<p>必须给出所有参数的类型，不过，只要函数不是递归的，就不需要指定返回类型。Scala编译器可以通过=右侧的表达式推断出返回类型。</p>
<p>如果函数体需要多个表达式完成，可以使用代码块，块中最后一个表达式的值就是函数的返回值。</p>
<p>对于递归函数，必须指定返回类型。</p>
<h3 id="默认参数和带名参数"><a href="#默认参数和带名参数" class="headerlink" title="默认参数和带名参数"></a>默认参数和带名参数</h3><p>scala中可以给函数提供默认参数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span></span>(num:<span class="type">Int</span> = <span class="number">2</span>) num += <span class="number">3</span></div></pre></td></tr></table></figure></p>
<p>还可以在提供参数值的时候指定参数名。带名参数不需要跟参数列表的顺序完全一致。</p>
<h3 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h3><p>scala中还支持接收可变长度参数列表：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(args: <span class="type">Int</span>*)&#123;</div><div class="line">    <span class="keyword">var</span> result = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span>(arg &lt;- args) result += arg</div><div class="line">    result</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数得到的是一个类型为Seq的参数。</p>
<p>如果你已经有一个值的序列，则不能直接将它传进上述函数。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = sum(<span class="number">1</span> to <span class="number">5</span>) <span class="comment">//错误</span></div></pre></td></tr></table></figure></p>
<p>如果sum函数被调用时传入的是单个参数，那么该参数必须是单个整数，而不是一个整数区间。解决这个问题的办法是告诉编译器你希望这个参数被当作参数序列来处理，追加：_*。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = sum(<span class="number">1</span> to <span class="number">5</span>: _*)</div></pre></td></tr></table></figure></p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>scala中不返回值的函数有特殊的表示法，如果函数体包含在花括号当中，但没有前面的=号，那么返回类型就是Unit。这样的函数称之为过程。</p>
<p>由于过程不返回值，所以我们省略=号。</p>
<h3 id="懒值"><a href="#懒值" class="headerlink" title="懒值"></a>懒值</h3><p>当val被声明为lazy时，它的初始化将被推迟，直到我们首次对它赋值。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> words = scala.io.<span class="type">Source</span>.fromFile(<span class="string">"a.txt"</span>).mkString</div></pre></td></tr></table></figure></p>
<p>如果程序从不访问a.txt，那么它就不会被打开。<br>懒值对于初始化开销较大的初始化语句而言十分有用。</p>
<p>###　异常<br>scala异常工作机制与Java一样，但是scala没有受检异常。</p>
<p>throw有特殊的类型值Nothing，这在if/else语句中特别有用，如果一个分支的类型是Nothing，那么if/else表达式的类型就是另一个分支的类型。</p>
<p>捕获异常的语法采用模式匹配的语法，更通用的异常应该排在更具体的异常后面。</p>
<p>如果不需要使用捕获的异常名，可以使用_代替变量名。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;条件表达式&quot;&gt;&lt;a href=&quot;#条件表达式&quot; class=&quot;headerlink&quot; title=&quot;条件表达式&quot;&gt;&lt;/a&gt;条件表达式&lt;/h3&gt;&lt;p&gt;scala的if/esle语法结构与Java一样，但是在scala中if/else表达式有值，这个值就是跟在if或e
    
    </summary>
    
      <category term="scala" scheme="http://nummy.github.io/categories/scala/"/>
    
    
      <category term="scala" scheme="http://nummy.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>scala学习笔记【1】基础</title>
    <link href="http://nummy.github.io/2016/09/03/scala-base/"/>
    <id>http://nummy.github.io/2016/09/03/scala-base/</id>
    <published>2016-09-03T02:01:41.000Z</published>
    <updated>2016-09-03T02:25:14.047Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用类型"><a href="#常用类型" class="headerlink" title="常用类型"></a>常用类型</h3><p>scala中常用类型如下：</p>
<ul>
<li>Byte</li>
<li>Char</li>
<li>Short</li>
<li>Int</li>
<li>Long</li>
<li>Float</li>
<li>Double</li>
<li>Booean</li>
</ul>
<p>这些类型都是类，所以在scala中不需要包装类型，在基本类型和包装类型之间的转换工作是scala编译器的事。</p>
<p>在scala中，我们使用方法而不是强制类型转换，来做数值类型之间的转换。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">99.44</span>.toInt         <span class="comment">// 99</span></div><div class="line"><span class="number">99.</span>toChar           <span class="comment">// 'c'</span></div></pre></td></tr></table></figure></p>
<p>和Java一样，toString将任意对象转换成字符串，要将包含了数字的字符串转换成数字，使用toInt或者toDouble。</p>
<h3 id="算术和操作符重载"><a href="#算术和操作符重载" class="headerlink" title="算术和操作符重载"></a>算术和操作符重载</h3><p>和Java相比，Scala并没有提供++和–操作符，我们需要使用+=1或者-=1；</p>
<p>对于常规的BigInt和BigDecimal对象，我们可以使用常规的方法使用那些数学操作符：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x:<span class="type">BigInt</span> = <span class="number">12121212</span></div><div class="line">x*x*x</div></pre></td></tr></table></figure></p>
<p>在java中，我们需要使用<code>x.multiply(x).multiply(x)</code>。</p>
<p>###　调用函数和方法<br>相比Java，在scala中使用数学函数更简单，我们不需要从某个类的调用它的静态方法。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.math._</div><div class="line">sqrt(<span class="number">2</span>)</div><div class="line">pow(<span class="number">2</span>,<span class="number">4</span>)</div></pre></td></tr></table></figure></p>
<p>在使用以scala开头的包时，我们可以省略scala的前缀。例如<code>import math._</code>等价于<code>import scala.math._</code>。</p>
<p>Scala中没有静态方法，但是提供了单例对象。</p>
<p>不带参数的方法通常不使用圆括号，一般来讲，没有参数并不改变当前对象的方法都不带圆括号。</p>
<p>scala中允许使用数字*字符串，从而实现复制字符串的功能。</p>
<h3 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h3><p>在scala中，我们通常使用类似函数调用的语法。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"Hello"</span>(<span class="number">4</span>) <span class="comment">// o</span></div></pre></td></tr></table></figure></p>
<p>你可以将这种用法当作()操作符的重载形式，它背后原理是实现一个名为apply的方法。所以<code>&quot;Hello&quot;(4)</code>相当于以下代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"Hello"</span>.apply(<span class="number">4</span>)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用类型&quot;&gt;&lt;a href=&quot;#常用类型&quot; class=&quot;headerlink&quot; title=&quot;常用类型&quot;&gt;&lt;/a&gt;常用类型&lt;/h3&gt;&lt;p&gt;scala中常用类型如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Byte&lt;/li&gt;
&lt;li&gt;Char&lt;/li&gt;
&lt;li&gt;Short&lt;/
    
    </summary>
    
      <category term="scala" scheme="http://nummy.github.io/categories/scala/"/>
    
    
      <category term="scala" scheme="http://nummy.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>runit快速入门</title>
    <link href="http://nummy.github.io/2016/08/17/runit-quick-tutorial/"/>
    <id>http://nummy.github.io/2016/08/17/runit-quick-tutorial/</id>
    <published>2016-08-17T15:18:43.000Z</published>
    <updated>2016-08-18T12:03:15.806Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>通过这篇教程，我们可以快速了解runit并搭建起相应服务。</p>
<p>runit是一个用于服务监控的UNIX软件，它提供以下两种服务：</p>
<ul>
<li>当服务器启动的时候启动定义好的服务。</li>
<li>监控运行的服务，当服务发生意外中断的时候，自动重启服务。</li>
</ul>
<p>这篇教程将通过一个简单的示例来讲解如何创建新的runit服务。如果你想了解更多信息，可以查看runit的<a href="http://smarden.org/runit/" target="_blank" rel="external">官方文档</a>。</p>
<p>本篇教程包括以下三部分：</p>
<ol>
<li>创建一个runit模板</li>
<li>创建第一个服务</li>
<li>如何自动管理服务</li>
</ol>
<h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>首先确保系统安装了runit，大多数Linux版本的软件仓库里都包哈了runit包。例如，如果你的系统是基于Debian的，则可以使用下面的命令进行安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># apt-get install runit</span></div></pre></td></tr></table></figure></p>
<p>如果是centos，则可以使用yum进行安装，但是默认情况下centos软件仓库里并没有runit，所以需要先配置相应的仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># curl -s https://packagecloud.io/install/repositories/imeyer/runit/script.rpm.sh | sudo bash</div><div class="line"># sudo yum install runit-2.1.1-7.el7.centos.x86_64</div></pre></td></tr></table></figure></p>
<p>运行以下命令来检查是否已经安装了runit并且系统已经运行了runit。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ps -ef | grep runsvdir</span></div></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root  2783   1  0 15:34 ? 00:00:00 runsvdir -P /etc/service log:</div></pre></td></tr></table></figure></p>
<p>runsvdir其实是一套组件，这些组件可以满足用户的各种需求，核心组件包括了runsvdir，runsv， chpst，svlogd以及sv。</p>
<h3 id="创建模板"><a href="#创建模板" class="headerlink" title="创建模板"></a>创建模板</h3><p>注意输出结果中的<code>runsvdir -P /etc/service log:.......</code>， 它的意思是runsvdir会监控<code>/etc/service/</code>目录下的文件，这些文件用于配置被监控的服务。</p>
<p>被监控的服务是通过在<code>/etc/service</code>目录下创建子目录，并添加可执行脚本run来实现的。</p>
<p>当runsvdir发现新的配置文件时，它就会自动启动一个runsv进程来管理这个配置的服务。</p>
<p>runit的设计思想就是每个组件的功能是完全独立的，以便管理。可以使用<code>man</code>命令查看具体组件的用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># man runsvdir</div></pre></td></tr></table></figure></p>
<p>确保存在<code>/etc/service</code>，如果不存在，则使用mkdir创建相应目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mkdir /etc/service</span></div></pre></td></tr></table></figure></p>
<p>为了便于开发与测试，这里我们不直接在<code>/etc/service/</code>目录中添加配置文件，而是创建一个暂存的目录来放置配置文件。<br>当我们满意自己的测试之后，再使用软链接，将暂存目录链接到<code>/etc/service</code>。</p>
<p>创建<code>/etc/runit</code>作为暂存目录。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mkdir  /etc/runit</span></div></pre></td></tr></table></figure></p>
<p>在创建一个真正的runit服务之前，我们先创建一个模板。这个模板将展示runit的基本用法，以后可以直接使用这个模板创建新的服务。<br>首先创建template目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># mkdir /etc/runit/template</div></pre></td></tr></table></figure></p>
<p>接下来，创建run脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh -e</div><div class="line">exec 2&gt;&amp;1</div><div class="line">exec chpst -u USER COMMAND</div></pre></td></tr></table></figure></p>
<p>给run添加可执行权限：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># chmod +x /etc/runit/template/run</span></div></pre></td></tr></table></figure></p>
<p>这个脚本首先将标准错误输出流输出到标准输出流，然后执行chpst命令。chpst命令用来指定使用哪个用户执行命令。由于run脚本默认被root用户执行，通过chpst可以将run配置为普通用户来执行。通过man命令可以查看chpst的更多信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># man chpst</span></div></pre></td></tr></table></figure></p>
<p>当runsvdir检查到<code>/etc/service</code>目录下包含一个新的目录时，runsvdir会启动一个runsv进程来执行和监控run脚本。通过man命令查看runsv的更多信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#man runsv</span></div></pre></td></tr></table></figure></p>
<p>你可能注意runsv还可以监控日志服务，日志在应用中非常的重要。下面创建一个日志模板。</p>
<p>首先创建log目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mkdir /etc/runit/template/log</span></div></pre></td></tr></table></figure></p>
<p>然后创建run脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="built_in">exec</span> chpst -u USER svlogd -tt LOGDIR</div></pre></td></tr></table></figure></p>
<p>给run脚本添加可执行权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># chmod +x /etc/runit/template/log/run</div></pre></td></tr></table></figure></p>
<p>上面的脚本使用chpst启动一个svlogd守护进程，该进程将日志信息写到LOGDIR目录中。<br>使用man命令获取更多关于svlodg的信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># man svlogd</span></div></pre></td></tr></table></figure></p>
<p>当runsvdir在<code>/etc/service/</code>目录中发现新的配置时，它会继续查找子目录log，如果找到了则启动runsv进程来执行和监控log目录下的run脚本。</p>
<h3 id="服务示例"><a href="#服务示例" class="headerlink" title="服务示例"></a>服务示例</h3><p>接下来，我们使用上面创建的模板来创建一个简单的服务配置。首先创建需要再run脚本中被chpst使用的用户:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># adduser foo</div></pre></td></tr></table></figure></p>
<p>接下来创建放置服务配置的目录，并将它的所属用户与用户组设置为foo。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mkdir /opt/example</span></div><div class="line"><span class="comment"># chown foo:foo /opt/example</span></div></pre></td></tr></table></figure></p>
<p>接下来切换到foo用户：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># su foo</span></div></pre></td></tr></table></figure></p>
<p>在<code>/opt/example</code>目录中添加脚本foo-service.sh：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"Started service..."</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..30&#125;</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"Doing stuff..."</span></div><div class="line">    sleep 1</div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"Oh no I crashed..."</span> &gt;&amp;2</div><div class="line"><span class="built_in">exit</span> 1</div></pre></td></tr></table></figure></p>
<p>给脚本赋予执行权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># chmod +x /opt/example/foo-service.sh</div></pre></td></tr></table></figure></p>
<p>上面的脚本模拟了一个真实的应用，每隔1秒打印一次日志信息，最后打印一次错误信息。可以尝试执行这个脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># /opt/example/foo-service.sh</div></pre></td></tr></table></figure></p>
<p>接下来创建包含日志服务的目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mkdir /opt/example/logs</span></div></pre></td></tr></table></figure></p>
<p>再切换回root用户。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># exit</div></pre></td></tr></table></figure></p>
<p>接下来使用之前创建的模板来监控这个示例服务，将暂存目录中的模板文件拷贝至新的目录example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># cp -R /etc/runit/template /etc/runit/example</div></pre></td></tr></table></figure></p>
<p>更新<code>/etc/runit/example/run</code>脚本的内容，使用foo用户来执行foo-service.sh脚本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh -e</div><div class="line">exec 2&gt;&amp;1</div><div class="line">exec chpst -u foo /opt/example/foo-service.sh</div></pre></td></tr></table></figure></p>
<p>同样的，更新<code>/etc/runit/example/log/run</code>脚本内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line">exec chpst -u foo svlogd -tt /opt/example/logs</div></pre></td></tr></table></figure></p>
<p>在将服务部署到<code>/etc/service</code>前，首先测试下配置是否正确：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># /etc/runit/example/run</div></pre></td></tr></table></figure></p>
<p>如果脚本运行正常，就可以部署服务了，创建一个软链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># ln -s /etc/runit/example /etc/service/example</div></pre></td></tr></table></figure></p>
<p>不出意外的话，runsvdir会检测到我们配置的两个服务，然后启动两个runsv进程来执行并监控服务。通过下面的命令可以检测服务是否正常运行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sv status example</span></div></pre></td></tr></table></figure></p>
<p>输出结果如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">run: example: (pid 3483) 3s; run: <span class="built_in">log</span>: (pid 3324) 154s</div></pre></td></tr></table></figure></p>
<p>使用tail命令可以查看日志信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># tail -f /opt/example/logs/current</span></div></pre></td></tr></table></figure></p>
<p>你会看到日志信息以及异常信息，接着服务重启。</p>
<h3 id="管理服务"><a href="#管理服务" class="headerlink" title="管理服务"></a>管理服务</h3><p>最后，我们再来学习下sv用法，sv用来手动管理我们的服务。</p>
<ol>
<li><p>检查服务的状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sv status example</div></pre></td></tr></table></figure>
</li>
<li><p>停止服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sv stop example</div></pre></td></tr></table></figure>
</li>
</ol>
<p>停止服务之后不会再输出日志信息，也不会再自动重启。</p>
<ol>
<li><p>重启服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sv restart example</div></pre></td></tr></table></figure>
</li>
<li><p>更多用法<br>``<br>man sv<br>```</p>
</li>
</ol>
<blockquote>
<p>译自：<a href="http://kchard.github.io/runit-quickstart/" target="_blank" rel="external">runit quick start</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h3&gt;&lt;p&gt;通过这篇教程，我们可以快速了解runit并搭建起相应服务。&lt;/p&gt;
&lt;p&gt;runit是一个用于服务监控的UNIX软件，它提供以下两种服务：&lt;
    
    </summary>
    
      <category term="Linux" scheme="http://nummy.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://nummy.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>iterable vs. iterator vs. generator</title>
    <link href="http://nummy.github.io/2016/03/23/iterator-vs-generator/"/>
    <id>http://nummy.github.io/2016/03/23/iterator-vs-generator/</id>
    <published>2016-03-23T08:15:40.000Z</published>
    <updated>2016-03-23T08:27:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>版权所有，如需转载，请联系译者<br>原文地址<a href="http:
//nvie.com/posts/iterators-vs-generators/" target="_blank" rel="external">http://nvie.com/posts/iterators-vs-generators/</a></p>
</blockquote>
<p>在使用Python的过程中，很容易混淆如下几个关联的概念：</p>
<ul>
<li>容器(container)</li>
<li>可迭代对象(Iterable)</li>
<li>迭代器(Iterator)</li>
<li>生成器(generator)</li>
<li>生成器表达式</li>
<li>{list, set, dict} 解析式</li>
</ul>
<p>它们之间的关系如下表所示：<br><img src="http://upload-images.jianshu.io/upload_images/1677721-ff5b5bb12c51e4c3.png" alt=""></p>
<h3 id="容器（container"><a href="#容器（container" class="headerlink" title="容器（container)"></a>容器（container)</h3><p>容器是用来储存元素的一种数据结构，它支持隶属测试，容器将所有数据保存在内存中，在Python中典型的容器有：</p>
<ul>
<li>list， deque, …</li>
<li>set，frozesets，…</li>
<li>dict, defaultdict, OrderedDict, Counter, …</li>
<li>tuple, namedtuple, …</li>
<li>str</li>
</ul>
<p>容器相对来说很好理解，因为你可以把它当成生活中的箱子、房子、船等等。<br>一般的，通过判断一个对象是否包含某个元素来确定它是否为一个容器。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">1</span> <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]       <span class="comment"># lists</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">4</span> <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">1</span> <span class="keyword">in</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;       <span class="comment"># sets</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">4</span> <span class="keyword">not</span> <span class="keyword">in</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">1</span> <span class="keyword">in</span> (<span class="number">12</span>,<span class="number">3</span>)        <span class="comment"># tuples</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">4</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>字典容器通过检查是否包含键来进行判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>:<span class="string">"foo"</span>, <span class="number">2</span>:<span class="string">"bar"</span>, <span class="number">3</span>:<span class="string">"qux"</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">1</span> <span class="keyword">in</span> d</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">4</span> <span class="keyword">not</span> <span class="keyword">in</span> d</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="string">"foo"</span> <span class="keyword">not</span> <span class="keyword">in</span> d</div></pre></td></tr></table></figure>
<p>字符串通过检查是否包含某个子 串来判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s =<span class="string">"foobar"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="string">"b"</span> <span class="keyword">in</span> s</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="string">"x"</span> <span class="keyword">not</span> <span class="keyword">in</span> s</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="string">"foo"</span> <span class="keyword">in</span> s</div></pre></td></tr></table></figure>
<blockquote>
<p> <strong>注意</strong>：并非所有的容器都是可迭代对象。</p>
</blockquote>
<h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><p>正如前面所提到的，大部分容器都是可迭代的，但是还有其他一些对象也可以迭代，例如，文件对象以及管道对象等等，容器一般来说存储的元素是有限的，同样的，可迭代对象也可以用来表示一个包含有限元素的数据结构。</p>
<p>可迭代对象可以为任意对象，不一定非得是基本数据结构，只要这个对象可以返回一个<strong>iterator</strong>。听起来可能有点费解，但是可迭代对象与迭代器之间有一个显著的区别。先看下面的例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x = [1,2,3]</div><div class="line">&gt;&gt;&gt; y = iter(x）</div><div class="line">&gt;&gt;&gt; z = iter(x)</div><div class="line">&gt;&gt;&gt; next(y)</div><div class="line">1</div><div class="line">&gt;&gt;&gt; next(y)</div><div class="line">2</div><div class="line">&gt;&gt;&gt; next(z)</div><div class="line">1</div><div class="line">&gt;&gt;&gt; type(x)</div><div class="line">&lt;class 'list'&gt;</div><div class="line">&gt;&gt;&gt; type(y)</div><div class="line">&lt;class 'list_iterator'&gt;</div></pre></td></tr></table></figure></p>
<p>在这里，x是可迭代对象，而y和z都是迭代器，它们从可迭代对象x中获取值。</p>
<blockquote>
<p><strong>注意</strong>：可迭代的类中，一般实现以下两个方法，<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当我们运行以下代码的时候:</div><div class="line">```Python</div><div class="line">x = [1,2,3]</div><div class="line">for elem in x:</div><div class="line">     ...</div></pre></td></tr></table></figure></p>
</blockquote>
<p>实际调用过程如下：<br><img src="http://upload-images.jianshu.io/upload_images/1677721-9453ca206b60475d.png" alt=""><br>当我们反向编译这段代Python码的时候，可以发现它显示调用了 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">```Python</div><div class="line">&gt;&gt;&gt; import dis</div><div class="line">&gt;&gt;&gt; x = [1, 2, 3]</div><div class="line">&gt;&gt;&gt; dis.dis(&apos;for _ in x: pass&apos;) </div><div class="line">1     0 SETUP_LOOP                     14 (to 17) </div><div class="line">       3 LOAD_NAME                       0 (x) </div><div class="line">       6 GET_ITER </div><div class="line"> &gt;&gt; 7 FOR_ITER                            6 (to 16) </div><div class="line">       10 STORE_NAME                    1 (_) </div><div class="line">       13 JUMP_ABSOLUTE               7 </div><div class="line"> &gt;&gt; 16 POP_BLOCK </div><div class="line"> &gt;&gt; 17 LOAD_CONST                    0 (None) </div><div class="line">       20 RETURN_VALUE</div></pre></td></tr></table></figure></p>
<h3 id="迭代器-Iterators"><a href="#迭代器-Iterators" class="headerlink" title="迭代器(Iterators)"></a>迭代器(Iterators)</h3><p>那么什么是迭代器呢？任何具有<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">所以迭代器本质上是一个产生值的工厂，每次向迭代器请求下一个值，迭代器都会进行计算出相应的值并返回。</div><div class="line"></div><div class="line">迭代器的例子很多，例如，所有```itertools ```模块中的函数都会返回一个迭代器，有的还可以产生无穷的序列。</div><div class="line">```Python</div><div class="line">&gt;&gt;&gt; from itertools import count</div><div class="line">&gt;&gt;&gt; counter = count(start=13)</div><div class="line">&gt;&gt;&gt; next(counter)</div><div class="line">13</div><div class="line">&gt;&gt;&gt; next（counter)</div><div class="line">14</div></pre></td></tr></table></figure></p>
<p>有的函数根据有限序列中生成无限序列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from itertools import cycle</div><div class="line">&gt;&gt;&gt; colors = cycle([&quot;red&quot;,&quot;white&quot;,&quot;blue&quot;])</div><div class="line">&gt;&gt;&gt; next(colors)</div><div class="line">&quot;red&quot;</div><div class="line">&gt;&gt;&gt; next(colors）</div><div class="line">&quot;white&quot;</div><div class="line">&gt;&gt;&gt; next(colors)</div><div class="line">&quot;blue&quot;</div><div class="line">&gt;&gt;&gt; next(colors)</div><div class="line">&quot;red&quot;</div></pre></td></tr></table></figure></p>
<p>有的函数根据无限序列中生成有限序列：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>colors = cycle([<span class="string">'red'</span>, <span class="string">'white'</span>, <span class="string">'blue'</span>])               <span class="comment"># infinite</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>limited = islice(colors, <span class="number">0</span>, <span class="number">4</span>)                          <span class="comment"># finite</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> limited:                                            <span class="comment"># so safe to use for-loop on</span></div><div class="line"><span class="meta">... </span>           print(x)</div><div class="line">red</div><div class="line">white</div><div class="line">blue</div><div class="line">red</div></pre></td></tr></table></figure></p>
<p>为了更好的理解迭代器的内部结构，我们先来定义一个生成斐波拉契数的迭代器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">fib</span>:</span></div><div class="line"><span class="meta">... </span>            <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>                  self.prev = <span class="number">0</span></div><div class="line"><span class="meta">... </span>                  self.curr = <span class="number">1</span></div><div class="line"><span class="meta">... </span></div><div class="line"><span class="meta">... </span>            <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>                  <span class="keyword">return</span> self</div><div class="line"><span class="meta">... </span></div><div class="line"><span class="meta">... </span>            <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>                  value = self.curr</div><div class="line"><span class="meta">... </span>                  self.curr += self.prev</div><div class="line"><span class="meta">... </span>                  self.prev = value</div><div class="line"><span class="meta">... </span>                  <span class="keyword">return</span> value</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = fib()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(islice(f, <span class="number">0</span>, <span class="number">10</span>))</div><div class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>]</div></pre></td></tr></table></figure></p>
<p>注意这个类既是可迭代的 （因为具有<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代器内部状态保存在当前实例对象的```prev```以及```cur```属性中，在下一次调用中将使用这两个属性。每次调用```next()```方法都会执行以下两步操作：</div><div class="line"></div><div class="line">1. 修改状态，以便下次调用```next()```方法</div><div class="line">2. 计算当前调用的结果</div><div class="line"></div><div class="line">&gt; **比喻**：从外部来看，迭代器就像政府工作人员一样，没人找他办事的时候（请求值），工作人员就闲着，当有人来找他的时候（请求值），工作人员就会忙一会，把请求的东西找出来交给请求的人。忙完之后，又没事了，继续闲着。</div><div class="line"></div><div class="line">### 生成器</div><div class="line"></div><div class="line">生成器其实就是一种特殊的迭代器。它使一种更为高级、更为优雅的迭代器。</div><div class="line">使用生成器让我们可以以一种更加简洁的语法来定义迭代器。</div><div class="line">让我们先明确以下两点：</div><div class="line">- 任意生成器都是迭代器（反过来不成立）</div><div class="line">- 任意生成器，都是一个可以延迟创建值的工厂</div><div class="line"></div><div class="line">下面也是一个生成斐波那契序列的工厂函数，不过是以生成器的方式编写的：</div><div class="line">```Python</div><div class="line">&gt;&gt;&gt; def fib():</div><div class="line">...            prev, curr = 0, 1</div><div class="line">...            while True:</div><div class="line">...                     yield curr</div><div class="line">...                     prev, curr = curr, prev + curr</div><div class="line">...</div><div class="line">&gt;&gt;&gt; f = fib()</div><div class="line">&gt;&gt;&gt; list(islice(f, 0, 10))</div><div class="line">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</div></pre></td></tr></table></figure></p>
<p>上面的代码是不是既优雅又简洁？注意其中用到的魔法关键字<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">yield</span></div></pre></td></tr></table></figure></p>
<p>一起来剖析下上面的代码：首先，fib其实是一个很普通的函数，但是函数中没有<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当调用```f = fib()```时，生成器被实例化并返回，这时并不会执行任何代码，生成器处于空闲状态，注意这里```prev, curr = 0, 1 ```并未执行。</div><div class="line"></div><div class="line">然后这个生成器被包含在```isslice()```中，而这又是一个迭代器，所以还是没有执行上面的代码。</div><div class="line"></div><div class="line">然后这个迭代器又被包含在```list()```中，它会根据传进来的参数生成一个列表。所以它首先对```isslice()```对象调用```next()```方法，```isslice()```对象又会对实例```f```调用```next()```。</div><div class="line">我们来看其中的一步操作，在第一次调用中，会执行```prev, curr = 0, 1```, 然后进入while循环，当遇到```yield curr```的时候，返回当前curr值，然后又进入空闲状态。</div><div class="line">生成的值传递给外层的```isslice()```，也相应生成一个值，然后传递给外层的```list()```，外层的list将这个值1添加到列表中。</div><div class="line">然后继续执行后面的九步操作，每步操作的流程都是一样的。</div><div class="line"></div><div class="line">然后执行到底11步的时候，```isslice()```对象就会抛出```StopIteration```异常，意味着已经到达末尾了。注意生成器不会接收到第11次```next()```请求，后面会被垃圾回收掉。</div><div class="line"></div><div class="line">### 生成器的类型</div><div class="line"></div><div class="line">在Python中两种类型的生成器：**生成器函数**以及**生成器表达式**。生成器函数就是包含```yield```参数的函数。生成器表达式与列表解析式类似。</div><div class="line">假设使用如下语法创建一个列表：</div><div class="line">```Python</div><div class="line">&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5, 6]</div><div class="line">&gt;&gt;&gt; [x * x for x in numbers]</div><div class="line">[1, 4, 9, 16, 25, 36]</div></pre></td></tr></table></figure></p>
<p>使用set解析式也可以达到同样的目的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &#123;x * x for x in numbers&#125;&#123;1, 4, 36, 9, 16, 25&#125;</div></pre></td></tr></table></figure></p>
<p>或者dict解析式:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x: x * x <span class="keyword">for</span> x <span class="keyword">in</span> numbers&#125;</div><div class="line">&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">5</span>: <span class="number">25</span>, <span class="number">6</span>: <span class="number">36</span>&#125;</div></pre></td></tr></table></figure></p>
<p>还可以使用生成器表达式:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lazy_squares = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> numbers)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lazy_squares</div><div class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x10d1f5510</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(lazy_squares)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(lazy_squares)</div><div class="line">[<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>]</div></pre></td></tr></table></figure></p>
<p>注意我们第一次调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 总结</div><div class="line"></div><div class="line">生成器是Python中一种非常强大的特性，它让我们能够编写更加简洁的代码，同时也更加节省内存，使用CPU也更加高效。</div><div class="line">使用生成器的小提示：在你的代码中找到与下面代码类似的地方：</div><div class="line">```Python</div><div class="line">def something(): </div><div class="line">      result = [] </div><div class="line">      for ... in ...: </div><div class="line">           result.append(x) </div><div class="line">      return result</div></pre></td></tr></table></figure></p>
<p>用以下代码进行替换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">iter_something</span><span class="params">()</span>:</span> </div><div class="line">      <span class="keyword">for</span> ... <span class="keyword">in</span> ...: </div><div class="line">            <span class="keyword">yield</span> x</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;版权所有，如需转载，请联系译者&lt;br&gt;原文地址&lt;a href=&quot;http:
//nvie.com/posts/iterators-vs-generators/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://nvie.
    
    </summary>
    
      <category term="python" scheme="http://nummy.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://nummy.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper的作用</title>
    <link href="http://nummy.github.io/2016/03/16/zookeeper/"/>
    <id>http://nummy.github.io/2016/03/16/zookeeper/</id>
    <published>2016-03-16T09:27:25.000Z</published>
    <updated>2016-03-16T09:32:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Zookeeper的官 网上有这么一句话：</p>
<blockquote>
<p>ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. </p>
</blockquote>
<p>这大概描述了Zookeeper主要可以干哪些事情：配置管理，名字服务，提供分布式同步以及集群管理。那这些服务又到底是什么呢？我们为什么需要这样的服务？我们又为什么要使用Zookeeper来实现呢，使用Zookeeper有什么优势？接下来我会挨个介绍这些到底是什么，以及有哪些开源系统中使用了。</p>
<h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>在我们的应用中除了代码外，还有一些就是各种配置。比如数据库连接等。一般我们都是使用配置文件的方式，在代码中引入这些配置文件。但是当我们只有一种配置，只有一台服务器，并且不经常修改的时候，使用配置文件是一个很好的做法，但是如果我们配置非常多，有很多服务器都需要这个配置，而且还可能是动态的话使用配置文件就不是个好主意了。这个时候往往需要寻找一种集中管理配置的方法，我们在这个集中的地方修改了配置，所有对这个配置感兴趣的都可以获得变更。比如我们可以把配置放在数据库里，然后所有需要配置的服务都去这个数据库读取配置。但是，因为很多服务的正常运行都非常依赖这个配置，所以需要这个集中提供配置服务的服务具备很高的可靠性。一般我们可以用一个集群来提供这个配置服务，但是用集群提升可靠性，那如何保证配置在集群中的一致性呢？ 这个时候就需要使用一种实现了一致性协议的服务了。Zookeeper就是这种服务，它使用Zab这种一致性协议来提供一致性。现在有很多开源项目使用Zookeeper来维护配置，比如在HBase中，客户端就是连接一个Zookeeper，获得必要的HBase集群的配置信息，然后才可以进一步操作。还有在开源的消息队列Kafka中，也使用Zookeeper来维护broker的信息。在Alibaba开源的SOA框架Dubbo中也广泛的使用Zookeeper管理一些配置来实现服务治理。</p>
<h3 id="名字服务"><a href="#名字服务" class="headerlink" title="名字服务"></a>名字服务</h3><p>名字服务这个就很好理解了。比如为了通过网络访问一个系统，我们得知道对方的IP地址，但是IP地址对人非常不友好，这个时候我们就需要使用域名来访问。但是计算机是不能识别域名的。怎么办呢？如果我们每台机器里都备有一份域名到IP地址的映射，这个倒是能解决一部分问题，但是如果域名对应的IP发生变化了又该怎么办呢？于是我们有了DNS这个东西。我们只需要访问一个大家熟知的(known)的点，它就会告诉你这个域名对应的IP是什么。在我们的应用中也会存在很多这类问题，特别是在我们的服务特别多的时候，如果我们在本地保存服务的地址的时候将非常不方便，但是如果我们只需要访问一个大家都熟知的访问点，这里提供统一的入口，那么维护起来将方便得多了。</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>Zookeeper是一个分布式协调服务。这样我们就可以利用Zookeeper来协调多个分布式进程之间的活动。比如在一个分布式环境中，为了提高可靠性，我们的集群的每台服务器上都部署着同样的服务。但是，一件事情如果集群中的每个服务器都进行的话，那相互之间就要协调，编程起来将非常复杂。而如果我们只让一个服务进行操作，那又存在单点。通常还有一种做法就是使用分布式锁，在某个时刻只让一个服务去干活，当这台服务出问题的时候锁释放，立即fail over到另外的服务。这在很多分布式系统中都是这么做，这种设计有一个更好听的名字叫Leader Election(leader选举)。比如HBase的Master就是采用这种机制。但要注意的是分布式锁跟同一个进程的锁还是有区别的，所以使用的时候要比同一个进程里的锁更谨慎的使用。</p>
<h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><p>在分布式的集群中，经常会由于各种原因，比如硬件故障，软件故障，网络问题，有些节点会进进出出。有新的节点加入进来，也有老的节点退出集群。这个时候，集群中其他机器需要感知到这种变化，然后根据这种变化做出对应的决策。比如我们是一个分布式存储系统，有一个中央控制节点负责存储的分配，当有新的存储进来的时候我们要根据现在集群目前的状态来分配存储节点。这个时候我们就需要动态感知到集群目前的状态。还有，比如一个分布式的SOA架构中，服务是一个集群提供的，当消费者访问某个服务时，就需要采用某种机制发现现在有哪些节点可以提供该服务(这也称之为服务发现，比如Alibaba开源的SOA框架Dubbo就采用了Zookeeper作为服务发现的底层机制)。还有开源的Kafka队列就采用了Zookeeper作为Cosnumer的上下线管理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Zookeeper的官 网上有这么一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ZooKeeper is a centralized service for maintaining configuration information, naming, providin
    
    </summary>
    
      <category term="Linux" scheme="http://nummy.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://nummy.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>HTML data属性</title>
    <link href="http://nummy.github.io/2016/03/09/html-data-attribute/"/>
    <id>http://nummy.github.io/2016/03/09/html-data-attribute/</id>
    <published>2016-03-08T16:26:26.000Z</published>
    <updated>2016-03-09T08:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>新的HTML5标准允许你在普通的元素标签里，嵌入类似data-*的属性，来实现一些简单数据的存取。它的数量不受限制，并且也能由javascript动态修改，也支持CSS选择器进行样式设置。这使得data属性特别灵活，也非常强大。有了这样的属性我们能够更加有序直观的进行数据预设或存储。</p>
<h3 id="使用data属性的简单示例"><a href="#使用data属性的简单示例" class="headerlink" title="使用data属性的简单示例"></a>使用data属性的简单示例</h3><p>例如，给一个<code>span</code>元素添加<code>data-date</code>属性，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;span data-date=&quot;2016.3.9&quot; id=&quot;demo&quot;&gt;Song&lt;/span&gt;</div></pre></td></tr></table></figure></p>
<p>由上可以看出，给HTML元素添加自定义属性，只需要使用<code>data-</code>前缀加上自定义属性名即可。</p>
<p>那么在JavaScript中如何操作自定义的属性值了，有以下四种方法。</p>
<h3 id="使用getAttribute以及setAttribute"><a href="#使用getAttribute以及setAttribute" class="headerlink" title="使用getAttribute以及setAttribute"></a>使用getAttribute以及setAttribute</h3><p>作为HTML元素的标签，dataset的存取也服从getAttribute、setAttribute，而且这两个方法兼容性也最广。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//获取属性</div><div class="line">var date = document.getElementById(&quot;demo&quot;).getAttribute(&quot;data-date&quot;);</div><div class="line"></div><div class="line">//设置属性</div><div class="line">document.getElementById(&quot;demo&quot;).setAttribute(&quot;data-date&quot;,&quot;2016.3.6&quot;);</div></pre></td></tr></table></figure></p>
<h3 id="使用dataset-API"><a href="#使用dataset-API" class="headerlink" title="使用dataset API"></a>使用dataset API</h3><p>通过.dataset API，我们可以更方便的获取元素的所有data字段，并以对象的方式，方便存取和遍历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//获取属性</div><div class="line">var date = document.getElementById(&quot;demo&quot;).dataset.date;</div><div class="line">console.log(date);</div><div class="line"></div><div class="line">//设置属性</div><div class="line">document.getElementById(&quot;demo&quot;).dataset.date = &quot;2016.3.8&quot;;</div><div class="line"></div><div class="line">//增加属性</div><div class="line">document.getElementById(&quot;demo&quot;).dataset.time = &quot;19:30&quot;;</div></pre></td></tr></table></figure></p>
<p>这时候我们在访问data时，就不需要”data-“关键词了，直接利用.dataset.name就可以访问到。这比上面的方法更方便。所做出的任何更改，都是可以实时反映到元素data属性上的。</p>
<p>如果涉及到连字符”-“，可以采取驼峰化的方法来存取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;span id=&quot;en&quot; data-user-name=&quot;nummy&quot;&gt;&lt;/span&gt;</div></pre></td></tr></table></figure></p>
<p>其中的<code>user-name</code>要写成<code>userName</code>。</p>
<h3 id="使用jQuery-attr方法"><a href="#使用jQuery-attr方法" class="headerlink" title="使用jQuery.attr方法"></a>使用jQuery.attr方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//获取属性</div><div class="line">var date = $(&quot;#demo&quot;).attr(&quot;data-date&quot;);</div><div class="line"></div><div class="line">//设置属性</div><div class="line">$(&quot;#demo&quot;).attr(&quot;data-date&quot;,&quot;2016.3.7&quot;);</div></pre></td></tr></table></figure>
<p>这与jQuery.attr运用在其他属性上时的情况完全一样，并且所做出的任何更改，都是可以实时反映到元素data属性上的。</p>
<h3 id="使用jQuery-data方法"><a href="#使用jQuery-data方法" class="headerlink" title="使用jQuery.data方法"></a>使用jQuery.data方法</h3><p>这个方法不需要使用<code>data-</code>关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//获取属性</div><div class="line">var date = $(&quot;#demo&quot;).data(&quot;date&quot;);</div><div class="line"></div><div class="line">//设置属性</div><div class="line">$(&quot;#demo&quot;).data(&quot;date&quot;,&quot;2016.3.7&quot;);</div></pre></td></tr></table></figure></p>
<p>这样的方法也能出色的存取data属性，但是需要注意，jQuery.data对data数据做出的更改，不会反映到HTML元素data属性上。也就是说在jQuery中<code>data-date</code>属性的值为<code>2016.3.7</code>，但是在HTML元素中还是为<code>2016.3.6</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新的HTML5标准允许你在普通的元素标签里，嵌入类似data-*的属性，来实现一些简单数据的存取。它的数量不受限制，并且也能由javascript动态修改，也支持CSS选择器进行样式设置。这使得data属性特别灵活，也非常强大。有了这样的属性我们能够更加有序直观的进行数据预
    
    </summary>
    
      <category term="js" scheme="http://nummy.github.io/categories/js/"/>
    
    
      <category term="javascript" scheme="http://nummy.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>jQuery通知提示插件toastr用法</title>
    <link href="http://nummy.github.io/2016/03/07/toastr/"/>
    <id>http://nummy.github.io/2016/03/07/toastr/</id>
    <published>2016-03-07T15:15:04.000Z</published>
    <updated>2016-03-08T07:20:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>toastr是一款非常棒的基于jquery库的非阻塞通知提示插件，toastr可设定四种通知模式：成功，出错，警告，提示，而提示窗口的位置，动画效果都可以通过能数来设置，在官方站可以通过勾选参数来生成JS，非常的方便使用。<br><img src="http://www.jqcool.net/wp-content/uploads/2014/06/2014-06-2812.png" alt=""></p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>引入核心文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;link href=&quot;toastr.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</div><div class="line">&lt;script src=&quot;http://libs.baidu.com/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;toastr.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>写入html代码，这里只需写入触发事件的按钮。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;button&quot; name=&quot;success&quot; id=&quot;success&quot; value=&quot;成功&quot;/&gt;</div><div class="line">&lt;input type=&quot;button&quot; name=&quot;info&quot; id=&quot;info&quot; value=&quot;提示&quot;/&gt;</div><div class="line">&lt;input type=&quot;button&quot; name=&quot;warning&quot; id=&quot;warning&quot; value=&quot;警告&quot;/&gt;</div><div class="line">&lt;input type=&quot;button&quot; name=&quot;error&quot; id=&quot;error&quot; value=&quot;错误&quot;/&gt;</div><div class="line">&lt;input type=&quot;button&quot; name=&quot;clear&quot; id=&quot;clear&quot; value=&quot;清除&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>给按钮绑定事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">$(function()&#123;</div><div class="line">    //参数设置，若用默认值可以省略以下面代</div><div class="line">    toastr.options = &#123;</div><div class="line">        &quot;closeButton&quot;: false, //是否显示关闭按钮</div><div class="line">        &quot;debug&quot;: false, //是否使用debug模式</div><div class="line">        &quot;positionClass&quot;: &quot;toast-top-full-width&quot;,//弹出窗的位置</div><div class="line">        &quot;showDuration&quot;: &quot;300&quot;,//显示的动画时间</div><div class="line">        &quot;hideDuration&quot;: &quot;1000&quot;,//消失的动画时间</div><div class="line">        &quot;timeOut&quot;: &quot;5000&quot;, //展现时间</div><div class="line">        &quot;extendedTimeOut&quot;: &quot;1000&quot;,//加长展示时间</div><div class="line">        &quot;showEasing&quot;: &quot;swing&quot;,//显示时的动画缓冲方式</div><div class="line">        &quot;hideEasing&quot;: &quot;linear&quot;,//消失时的动画缓冲方式</div><div class="line">        &quot;showMethod&quot;: &quot;fadeIn&quot;,//显示时的动画方式</div><div class="line">        &quot;hideMethod&quot;: &quot;fadeOut&quot; //消失时的动画方式</div><div class="line">        &#125;;</div><div class="line"> </div><div class="line">        //成功提示绑定</div><div class="line">        $(&quot;#success&quot;).click(function()&#123;</div><div class="line">        toastr.success(&quot;祝贺你成功了&quot;);</div><div class="line">        &#125;)</div><div class="line">         </div><div class="line">        //信息提示绑定</div><div class="line">        $(&quot;#info&quot;).click(function()&#123;</div><div class="line">        toastr.info(&quot;这是一个提示信息&quot;);</div><div class="line">        &#125;)</div><div class="line">         </div><div class="line">        //敬告提示绑定</div><div class="line">        $(&quot;#warning&quot;).click(function()&#123;</div><div class="line">        toastr.warning(&quot;警告你别来烦我了&quot;);</div><div class="line">        &#125;)</div><div class="line">         </div><div class="line">        //错语提示绑定</div><div class="line">        $(&quot;#error&quot;).click(function()&#123;</div><div class="line">        toastr.error(&quot;出现错误，请更改&quot;);</div><div class="line">        &#125;)</div><div class="line">         </div><div class="line">        //清除窗口绑定</div><div class="line">        $(&quot;#clear&quot;).click(function()&#123;</div><div class="line">        toastr.clear();</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;toastr是一款非常棒的基于jquery库的非阻塞通知提示插件，toastr可设定四种通知模式：成功，出错，警告，提示，而提示窗口的位置，
    
    </summary>
    
      <category term="js" scheme="http://nummy.github.io/categories/js/"/>
    
    
      <category term="javascript" scheme="http://nummy.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>PyMongo集合操作</title>
    <link href="http://nummy.github.io/2016/03/02/pymongocollection/"/>
    <id>http://nummy.github.io/2016/03/02/pymongocollection/</id>
    <published>2016-03-02T11:14:22.000Z</published>
    <updated>2016-03-03T03:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="批量执行写操作"><a href="#批量执行写操作" class="headerlink" title="批量执行写操作"></a>批量执行写操作</h3><blockquote>
<p><strong>bulk_write</strong>(requests, ordered=True, bypass_document_validation=False)</p>
</blockquote>
<p>使用列表的形式将请求发送给服务器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> doc <span class="keyword">in</span> db.test.find(&#123;&#125;):</div><div class="line"><span class="meta">... </span>    print(doc)</div><div class="line">...</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: ObjectId(<span class="string">'54f62e60fba5226811f634ef'</span>)&#125;</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: ObjectId(<span class="string">'54f62e60fba5226811f634f0'</span>)&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># DeleteMany, UpdateOne, and UpdateMany are also available.</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pymongo <span class="keyword">import</span> InsertOne, DeleteOne, ReplaceOne</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>requests = [InsertOne(&#123;<span class="string">'y'</span>: <span class="number">1</span>&#125;), DeleteOne(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;),</div><div class="line"><span class="meta">... </span>            ReplaceOne(&#123;<span class="string">'w'</span>: <span class="number">1</span>&#125;, &#123;<span class="string">'z'</span>: <span class="number">1</span>&#125;, upsert=<span class="keyword">True</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result = db.test.bulk_write(requests)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.inserted_count</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.deleted_count</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.modified_count</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.upserted_ids</div><div class="line">&#123;<span class="number">2</span>: ObjectId(<span class="string">'54f62ee28891e756a6e1abd5'</span>)&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> doc <span class="keyword">in</span> db.test.find(&#123;&#125;):</div><div class="line"><span class="meta">... </span>    print(doc)</div><div class="line">...</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: ObjectId(<span class="string">'54f62e60fba5226811f634f0'</span>)&#125;</div><div class="line">&#123;<span class="string">u'y'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: ObjectId(<span class="string">'54f62ee2fba5226811f634f1'</span>)&#125;</div><div class="line">&#123;<span class="string">u'z'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: ObjectId(<span class="string">'54f62ee28891e756a6e1abd5'</span>)&#125;</div></pre></td></tr></table></figure></p>
<h3 id="插入单个文档"><a href="#插入单个文档" class="headerlink" title="插入单个文档"></a>插入单个文档</h3><blockquote>
<p><strong>insert_one</strong>(document, bypass_document_validation=False)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.test.count(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result = db.test.insert_one(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.inserted_id</div><div class="line">ObjectId(<span class="string">'54f112defba522406c9cc208'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.test.find_one(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;)</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: ObjectId(<span class="string">'54f112defba522406c9cc208'</span>)&#125;</div></pre></td></tr></table></figure>
<h3 id="插入多个文档"><a href="#插入多个文档" class="headerlink" title="插入多个文档"></a>插入多个文档</h3><blockquote>
<p><strong>insert_many</strong>(documents, ordered=True, bypass_document_validation=False)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.test.count()</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result = db.test.insert_many([&#123;<span class="string">'x'</span>: i&#125; <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.inserted_ids</div><div class="line">[ObjectId(<span class="string">'54f113fffba522406c9cc20e'</span>), ObjectId(<span class="string">'54f113fffba522406c9cc20f'</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.test.count()</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<h3 id="替换某个文档"><a href="#替换某个文档" class="headerlink" title="替换某个文档"></a>替换某个文档</h3><blockquote>
<p><strong>replace_one</strong>(filter, replacement, upsert=False, bypass_document_validation=False)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> doc <span class="keyword">in</span> db.test.find(&#123;&#125;):</div><div class="line"><span class="meta">... </span>    print(doc)</div><div class="line">...</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: ObjectId(<span class="string">'54f4c5befba5220aa4d6dee7'</span>)&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result = db.test.replace_one(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;, &#123;<span class="string">'y'</span>: <span class="number">1</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.matched_count</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.modified_count</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> doc <span class="keyword">in</span> db.test.find(&#123;&#125;):</div><div class="line"><span class="meta">... </span>    print(doc)</div><div class="line">...</div><div class="line">&#123;<span class="string">u'y'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: ObjectId(<span class="string">'54f4c5befba5220aa4d6dee7'</span>)&#125;</div></pre></td></tr></table></figure>
<p>如果设置upsert为True的话，当没有找到匹配文档的时候，会直接插入新的文档。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>result = db.test.replace_one(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;, &#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;, <span class="keyword">True</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.matched_count</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.modified_count</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.upserted_id</div><div class="line">ObjectId(<span class="string">'54f11e5c8891e756a6e1abd4'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.test.find_one(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;)</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: ObjectId(<span class="string">'54f11e5c8891e756a6e1abd4'</span>)&#125;</div></pre></td></tr></table></figure></p>
<h3 id="更新某个文档"><a href="#更新某个文档" class="headerlink" title="更新某个文档"></a>更新某个文档</h3><blockquote>
<p><strong>update_one</strong>(filter, update, upsert=False, bypass_document_validation=False)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> doc <span class="keyword">in</span> db.test.find():</div><div class="line"><span class="meta">... </span>    print(doc)</div><div class="line">...</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: <span class="number">0</span>&#125;</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: <span class="number">1</span>&#125;</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: <span class="number">2</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result = db.test.update_one(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;, &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'x'</span>: <span class="number">3</span>&#125;&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.matched_count</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.modified_count</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> doc <span class="keyword">in</span> db.test.find():</div><div class="line"><span class="meta">... </span>    print(doc)</div><div class="line">...</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">4</span>, <span class="string">u'_id'</span>: <span class="number">0</span>&#125;</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: <span class="number">1</span>&#125;</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>同样的，如果upsert为True的话，匹配文档不存在的时候会直接创建新的文档。</p>
<h3 id="更新多个文档"><a href="#更新多个文档" class="headerlink" title="更新多个文档"></a>更新多个文档</h3><blockquote>
<p><strong>update_many</strong>(filter, update, upsert=False, bypass_document_validation=False)</p>
</blockquote>
<p>同时更新多个满足匹配条件的文档<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> doc <span class="keyword">in</span> db.test.find():</div><div class="line"><span class="meta">... </span>    print(doc)</div><div class="line">...</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: <span class="number">0</span>&#125;</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: <span class="number">1</span>&#125;</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: <span class="number">2</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result = db.test.update_many(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;, &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'x'</span>: <span class="number">3</span>&#125;&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.matched_count</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.modified_count</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> doc <span class="keyword">in</span> db.test.find():</div><div class="line"><span class="meta">... </span>    print(doc)</div><div class="line">...</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">4</span>, <span class="string">u'_id'</span>: <span class="number">0</span>&#125;</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">4</span>, <span class="string">u'_id'</span>: <span class="number">1</span>&#125;</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">4</span>, <span class="string">u'_id'</span>: <span class="number">2</span>&#125;</div></pre></td></tr></table></figure></p>
<h3 id="删除单个文档"><a href="#删除单个文档" class="headerlink" title="删除单个文档"></a>删除单个文档</h3><blockquote>
<p><strong>delete_one</strong>(filter)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.test.count(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result = db.test.delete_one(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.deleted_count</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.test.count(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;)</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<h3 id="删除多个文档"><a href="#删除多个文档" class="headerlink" title="删除多个文档"></a>删除多个文档</h3><blockquote>
<p><em>*delete_many</em>(filter)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.test.count(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result = db.test.delete_many(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.deleted_count</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.test.count(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;)</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>
<h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.test.find(&#123;<span class="string">"hello"</span>: <span class="string">"world"</span>&#125;)</div></pre></td></tr></table></figure>
<h3 id="查询单个文档"><a href="#查询单个文档" class="headerlink" title="查询单个文档"></a>查询单个文档</h3><p>使用<code>find_one()</code>进行查询，如果找到则返回，如果没找到则返回None。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>find_one(max_time_ms=<span class="number">100</span>)</div></pre></td></tr></table></figure></p>
<h3 id="查询某个文档并执行删除操作"><a href="#查询某个文档并执行删除操作" class="headerlink" title="查询某个文档并执行删除操作"></a>查询某个文档并执行删除操作</h3><blockquote>
<p><strong>find_one_and_delete</strong>(filter, projection=None, sort=None, **kwargs)</p>
</blockquote>
<p>返回查询到的文档</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.test.count(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.test.find_one_and_delete(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;)</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: ObjectId(<span class="string">'54f4e12bfba5220aa4d6dee8'</span>)&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.test.count(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<h3 id="查询某个文档并将其替换成新文档"><a href="#查询某个文档并将其替换成新文档" class="headerlink" title="查询某个文档并将其替换成新文档"></a>查询某个文档并将其替换成新文档</h3><blockquote>
<p><strong>find_one_and_replace</strong>()</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> doc <span class="keyword">in</span> db.test.find(&#123;&#125;):</div><div class="line"><span class="meta">... </span>    print(doc)</div><div class="line">...</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: <span class="number">0</span>&#125;</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: <span class="number">1</span>&#125;</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: <span class="number">2</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.test.find_one_and_replace(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;, &#123;<span class="string">'y'</span>: <span class="number">1</span>&#125;)</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: <span class="number">0</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> doc <span class="keyword">in</span> db.test.find(&#123;&#125;):</div><div class="line"><span class="meta">... </span>    print(doc)</div><div class="line">...</div><div class="line">&#123;<span class="string">u'y'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: <span class="number">0</span>&#125;</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: <span class="number">1</span>&#125;</div><div class="line">&#123;<span class="string">u'x'</span>: <span class="number">1</span>, <span class="string">u'_id'</span>: <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<h3 id="查询某个文档并进行更新"><a href="#查询某个文档并进行更新" class="headerlink" title="查询某个文档并进行更新"></a>查询某个文档并进行更新</h3><blockquote>
<p><strong>find_one_and_update</strong>()</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.test.find_one_and_update(</div><div class="line"><span class="meta">... </span>   &#123;<span class="string">'_id'</span>: <span class="number">665</span>&#125;, &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'count'</span>: <span class="number">1</span>&#125;, <span class="string">'$set'</span>: &#123;<span class="string">'done'</span>: <span class="keyword">True</span>&#125;&#125;)</div><div class="line">&#123;<span class="string">u'_id'</span>: <span class="number">665</span>, <span class="string">u'done'</span>: <span class="keyword">False</span>, <span class="string">u'count'</span>: <span class="number">25</span>&#125;&#125;</div></pre></td></tr></table></figure>
<p>如果upsert设置为True，则当匹配文档不存在的时候，创建新的文档。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.example.delete_many(&#123;&#125;).deleted_count</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>db.example.find_one_and_update(</div><div class="line"><span class="meta">... </span>    &#123;<span class="string">'_id'</span>: <span class="string">'userid'</span>&#125;,</div><div class="line"><span class="meta">... </span>    &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'seq'</span>: <span class="number">1</span>&#125;&#125;,</div><div class="line"><span class="meta">... </span>    projection=&#123;<span class="string">'seq'</span>: <span class="keyword">True</span>, <span class="string">'_id'</span>: <span class="keyword">False</span>&#125;,</div><div class="line"><span class="meta">... </span>    upsert=<span class="keyword">True</span>,</div><div class="line"><span class="meta">... </span>    return_document=ReturnDocument.AFTER)</div><div class="line">&#123;<span class="string">u'seq'</span>: <span class="number">1</span>&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;批量执行写操作&quot;&gt;&lt;a href=&quot;#批量执行写操作&quot; class=&quot;headerlink&quot; title=&quot;批量执行写操作&quot;&gt;&lt;/a&gt;批量执行写操作&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;bulk_write&lt;/strong&gt;(requests,
    
    </summary>
    
      <category term="python" scheme="http://nummy.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://nummy.github.io/tags/python/"/>
    
      <category term="mongodb" scheme="http://nummy.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>PyCharm快捷键</title>
    <link href="http://nummy.github.io/2016/03/02/pycharm/"/>
    <id>http://nummy.github.io/2016/03/02/pycharm/</id>
    <published>2016-03-01T16:05:59.000Z</published>
    <updated>2016-03-02T08:09:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>CTRL Q: 在参数列表位置，显示可以输入的所有参数。<br>CTRL Q: 查看选中方法的文档字符串</p>
<h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p>CTRL -: 折叠当前代码<br>CTRL +: 展开当前代码<br>CTRL SHIFT -: 折叠所有代码<br>CTRL SHIFT +: 展开所有代码<br>CTRL SHIFT F7: 将当前单词在整个文件中高亮，F3移动到下一个，ESC取消高亮。<br>CTRL F11 | F11: 设置书签.<br>SHIFT F11: 显示所有书签。<br>CTRL F12: 当一个文件中方法太多，要快速跳到某个方法时，可以用此快捷键打开LIST,<br>除了用上下箭选择外，还可以输入字母。</p>
<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>ALT UP: 移到上一个方法<br>ALT DOWN: 移到下一个方法<br>CTRL B | CTRL 单击： 转到方法定义处<br>CTRL SHIFT UP: 将当前行上移一行<br>CTRL SHIFT UP: 将当前行下移一行</p>
<p>SHIFT ENTER: 在行中间执行时，智能跳到下一行。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>CTRL /: 注释、取消注释行</p>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>ALT 左键： 列模式选择<br>CTRL W: 选中当前单词，继续按，选中它所属的行/IF/方法.</p>
<h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>CTRL D: 未选中时，复制当前行到下一行，选中时复制粘贴选中部分。<br>CTRL J: 输入模板</p>
<p>SHIFT F6: 更改变量/方法名字</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>CTRY Y: 删除当前行</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>CTRL F8: 设置/取消断点</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>CTRL E: 最近访问的文件列表<br>ESC: 焦点从其它窗口到编辑窗口<br>SHIFT ESC: 隐藏当前窗口，焦点到编辑窗口<br>F12: 焦点从编辑窗口到上一个使用窗口<br>编辑器右键，local history, show history： 显示本地修改记录<br><img src="http://images.cnitblog.com/blog/23013/201402/191435131665539.png" alt="pycharm快捷键"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;提示&quot;&gt;&lt;a href=&quot;#提示&quot; class=&quot;headerlink&quot; title=&quot;提示&quot;&gt;&lt;/a&gt;提示&lt;/h3&gt;&lt;p&gt;CTRL Q: 在参数列表位置，显示可以输入的所有参数。&lt;br&gt;CTRL Q: 查看选中方法的文档字符串&lt;/p&gt;
&lt;h3 id=&quot;阅读&quot;&gt;&lt;
    
    </summary>
    
      <category term="python" scheme="http://nummy.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://nummy.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python Requests 快速入门</title>
    <link href="http://nummy.github.io/2016/02/28/requests/"/>
    <id>http://nummy.github.io/2016/02/28/requests/</id>
    <published>2016-02-28T14:00:41.000Z</published>
    <updated>2016-02-29T06:32:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用pip进行安装<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install Requests</div></pre></td></tr></table></figure></p>
<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>使用Requests发送网络请求非常简单，一开始要导入Requests模块:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</div></pre></td></tr></table></figure></p>
<p>然后，尝试获取某个网页。本例子中，我们来获取Github的公共时间线<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)</div></pre></td></tr></table></figure></p>
<p>现在，我们有一个名为 r 的 Response 对象。可以从这个对象中获取所有我们想要的信息。<br>Requests简便的API意味着所有HTTP请求类型都是显而易见的。例如，你可以这样发送一个HTTP POST请求:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(<span class="string">"http://httpbin.org/post"</span>)</div></pre></td></tr></table></figure></p>
<p>漂亮，对吧？那么其他HTTP请求类型：PUT， DELETE， HEAD以及OPTIONS又是如何的呢？都是一样的简单:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.put(<span class="string">"http://httpbin.org/put"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.delete(<span class="string">"http://httpbin.org/delete"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.head(<span class="string">"http://httpbin.org/get"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.options(<span class="string">"http://httpbin.org/get"</span>)</div></pre></td></tr></table></figure></p>
<p>都很不错吧，但这也仅是Requests的冰山一角呢。</p>
<h3 id="为URL传递参数"><a href="#为URL传递参数" class="headerlink" title="为URL传递参数"></a>为URL传递参数</h3><p>你也许经常想为URL的查询字符串(query string)传递某种数据。如果你是手工构建URL，那么数据会以键/值 对的形式置于URL中，跟在一个问号的后面。例如，<code>httpbin.org/get?key=val</code> 。 <code>Requests</code>允许你使用 <code>params</code> 关键字参数，以一个字典来提供这些参数。举例来说，如果你想传递 <code>key1=value1</code> 和 <code>key2=value2</code> 到 <code>httpbin.org/get</code> ，那么你可以使用如下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">"http://httpbin.org/get"</span>, params=payload)</div></pre></td></tr></table></figure></p>
<p>通过打印输出该URL，你能看到URL已被正确编码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> r.url</div><div class="line"><span class="string">u'http://httpbin.org/get?key2=value2&amp;key1=value1'</span></div></pre></td></tr></table></figure></p>
<h3 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h3><p>我们能读取服务器响应的内容。再次以Github时间线为例:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line"><span class="string">'[&#123;"repository":&#123;"open_issues":0,"url":"https://github.com/"...'</span></div></pre></td></tr></table></figure></p>
<p>Requests会自动解码来自服务器的内容。大多数unicode字符集都能被无缝地解码。<br>请求发出后，Requests会基于HTTP头部对响应的编码作出有根据的推测。当你访问r.text 之时，Requests会使用其推测的文本编码。你可以找出Requests使用了什么编码，并且能够使用 r.encoding 属性来改变它:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.encoding</div><div class="line"><span class="string">'utf-8'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.encoding = <span class="string">'ISO-8859-1'</span></div></pre></td></tr></table></figure></p>
<p>如果你改变了编码，每当你访问 r.text ，Request都将会使用 r.encoding 的新值。<br>在你需要的情况下，Requests也可以使用定制的编码。如果你创建了自己的编码，并使用codecs 模块进行注册，你就可以轻松地使用这个解码器名称作为 r.encoding 的值， 然后由Requests来为你处理编码。</p>
<h3 id="二进制响应内容"><a href="#二进制响应内容" class="headerlink" title="二进制响应内容"></a>二进制响应内容</h3><p>你也能以字节的方式访问请求响应体，对于非文本请求:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.content</div><div class="line"><span class="string">b'[&#123;"repository":&#123;"open_issues":0,"url":"https://github.com/...'</span></div></pre></td></tr></table></figure></p>
<p>Requests会自动为你解码 gzip 和 deflate 传输编码的响应数据。<br>例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> StringIO <span class="keyword">import</span> StringIO</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>i = Image.open(StringIO(r.content))</div></pre></td></tr></table></figure></p>
<h3 id="JSON响应内容"><a href="#JSON响应内容" class="headerlink" title="JSON响应内容"></a>JSON响应内容</h3><p>Requests中也有一个内置的JSON解码器，助你处理JSON数据:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.json()</div><div class="line">[&#123;<span class="string">u'repository'</span>: &#123;<span class="string">u'open_issues'</span>: <span class="number">0</span>, <span class="string">u'url'</span>: <span class="string">'https://github.com/...'</span>&#125;]</div></pre></td></tr></table></figure></p>
<p>如果JSON解码失败， r.json 就会抛出一个异常。</p>
<h3 id="原始响应内容"><a href="#原始响应内容" class="headerlink" title="原始响应内容"></a>原始响应内容</h3><p>在罕见的情况下你可能想获取来自服务器的原始套接字响应，那么你可以访问 <code>r.raw</code> 。 如果你确实想这么干，那请你确保在初始请求中设置了 <code>stream=True</code> 。具体的你可以这么做:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://github.com/timeline.json'</span>, stream=<span class="keyword">True</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.raw</div><div class="line">&lt;requests.packages.urllib3.response.HTTPResponse object at <span class="number">0x101194810</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.raw.read(<span class="number">10</span>)</div><div class="line"><span class="string">'\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03'</span></div></pre></td></tr></table></figure></p>
<h3 id="定制请求头"><a href="#定制请求头" class="headerlink" title="定制请求头"></a>定制请求头</h3><p>如果你想为请求添加HTTP头部，只要简单地传递一个 dict 给 headers 参数就可以了。<br>例如，在前一个示例中我们没有指定content-type:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://api.github.com/some/endpoint'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>payload = &#123;<span class="string">'some'</span>: <span class="string">'data'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>headers = &#123;<span class="string">'content-type'</span>: <span class="string">'application/json'</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, data=json.dumps(payload), headers=headers)</div></pre></td></tr></table></figure></p>
<h3 id="更加复杂的POST请求"><a href="#更加复杂的POST请求" class="headerlink" title="更加复杂的POST请求"></a>更加复杂的POST请求</h3><p>通常，你想要发送一些编码为表单形式的数据—非常像一个HTML表单。 要实现这个，只需简单地传递一个字典给 data 参数。你的数据字典 在发出请求时会自动编码为表单形式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(<span class="string">"http://httpbin.org/post"</span>, data=payload)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> r.text</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  <span class="string">"form"</span>: &#123;</div><div class="line">    <span class="string">"key2"</span>: <span class="string">"value2"</span>,</div><div class="line">    <span class="string">"key1"</span>: <span class="string">"value1"</span></div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 string 而不是一个dict ，那么数据会被直接发布出去。<br>例如，Github API v3接受编码为JSON的POST/PATCH数据:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://api.github.com/some/endpoint'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>payload = &#123;<span class="string">'some'</span>: <span class="string">'data'</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, data=json.dumps(payload))</div></pre></td></tr></table></figure>
<h3 id="POST一个文件"><a href="#POST一个文件" class="headerlink" title="POST一个文件"></a>POST一个文件</h3><p>Requests使得上传文件变得很简单:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">'file'</span>: open(<span class="string">'report.xls'</span>, <span class="string">'rb'</span>)&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  <span class="string">"files"</span>: &#123;</div><div class="line">    <span class="string">"file"</span>: <span class="string">"&lt;censored...binary...data&gt;"</span></div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以显式地设置文件名:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">'file'</span>: (<span class="string">'report.xls'</span>, open(<span class="string">'report.xls'</span>, <span class="string">'rb'</span>))&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  <span class="string">"files"</span>: &#123;</div><div class="line">    <span class="string">"file"</span>: <span class="string">"&lt;censored...binary...data&gt;"</span></div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你想，你也可以发送作为文件来接收的字符串:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">'file'</span>: (<span class="string">'report.csv'</span>, <span class="string">'some,data,to,send\nanother,row,to,send\n'</span>)&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  <span class="string">"files"</span>: &#123;</div><div class="line">    <span class="string">"file"</span>: <span class="string">"some,data,to,send\\nanother,row,to,send\\n"</span></div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><p>我们可以检测响应状态码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://httpbin.org/get'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">200</span></div></pre></td></tr></table></figure></p>
<p>为方便引用，Requests还附带了一个内置的状态码查询对象:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code == requests.codes.ok</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure></p>
<p>如果发送了一个失败请求(非200响应)，我们可以通过 Response.raise_for_status() 来抛出异常:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>bad_r = requests.get(<span class="string">'http://httpbin.org/status/404'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bad_r.status_code</div><div class="line"><span class="number">404</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bad_r.raise_for_status()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"requests/models.py"</span>, line <span class="number">832</span>, <span class="keyword">in</span> raise_for_status</div><div class="line">    <span class="keyword">raise</span> http_error</div><div class="line">requests.exceptions.HTTPError: <span class="number">404</span> Client Error</div></pre></td></tr></table></figure></p>
<p>但是，由于我们的例子中 r 的 status_code 是 200 ，当我们调用 raise_for_status() 时，得到的是:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.raise_for_status()</div><div class="line"><span class="keyword">None</span></div></pre></td></tr></table></figure></p>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>我们可以查看以一个Python字典形式展示的服务器响应头:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers</div><div class="line">&#123;</div><div class="line">    <span class="string">'status'</span>: <span class="string">'200 OK'</span>,</div><div class="line">    <span class="string">'content-encoding'</span>: <span class="string">'gzip'</span>,</div><div class="line">    <span class="string">'transfer-encoding'</span>: <span class="string">'chunked'</span>,</div><div class="line">    <span class="string">'connection'</span>: <span class="string">'close'</span>,</div><div class="line">    <span class="string">'server'</span>: <span class="string">'nginx/1.0.4'</span>,</div><div class="line">    <span class="string">'x-runtime'</span>: <span class="string">'148ms'</span>,</div><div class="line">    <span class="string">'etag'</span>: <span class="string">'"e1ca502697e5c9317743dc078f67693f"'</span>,</div><div class="line">    <span class="string">'content-type'</span>: <span class="string">'application/json; charset=utf-8'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是这个字典比较特殊：它是仅为HTTP头部而生的。根据 RFC 2616 ， HTTP头部是大小写不敏感的。<br>因此，我们可以使用任意大写形式来访问这些响应头字段:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers[<span class="string">'Content-Type'</span>]</div><div class="line"><span class="string">'application/json; charset=utf-8'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers.get(<span class="string">'content-type'</span>)</div><div class="line"><span class="string">'application/json; charset=utf-8'</span></div></pre></td></tr></table></figure></p>
<p>如果某个响应头字段不存在，那么它的默认值为 None<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers[<span class="string">'X-Random'</span>]</div><div class="line"><span class="keyword">None</span></div></pre></td></tr></table></figure></p>
<h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>如果某个响应中包含一些Cookie，你可以快速访问它们:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://example.com/some/cookie/setting/url'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.cookies[<span class="string">'example_cookie_name'</span>]</div><div class="line"><span class="string">'example_cookie_value'</span></div></pre></td></tr></table></figure></p>
<p>要想发送你的cookies到服务器，可以使用 cookies 参数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/cookies'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>cookies = dict(cookies_are=<span class="string">'working'</span>)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url, cookies=cookies)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line"><span class="string">'&#123;"cookies": &#123;"cookies_are": "working"&#125;&#125;'</span></div></pre></td></tr></table></figure></p>
<h3 id="重定向与请求历史"><a href="#重定向与请求历史" class="headerlink" title="重定向与请求历史"></a>重定向与请求历史</h3><p>使用<code>GET</code>或<code>OPTIONS</code>时，<code>Requests</code>会自动处理位置重定向。<br><code>Github</code>将所有的<code>HTTP</code>请求重定向到<code>HTTPS</code>。可以使用响应对象的 <code>history</code> 方法来追踪重定向。 我们来看看<code>Github</code>做了什么:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://github.com'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.url</div><div class="line"><span class="string">'https://github.com/'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">200</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.history</div><div class="line">[&lt;Response [<span class="number">301</span>]&gt;]</div></pre></td></tr></table></figure></p>
<p><code>Response.history</code> 是一个<code>:class:Request</code> 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。<br>如果你使用的是GET或OPTIONS，那么你可以通过<code>allow_redirects</code>参数禁用重定向处理:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://github.com'</span>, allow_redirects=<span class="keyword">False</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">301</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.history</div><div class="line">[]</div></pre></td></tr></table></figure></p>
<p>如果你使用的是POST，PUT，PATCH，DELETE或HEAD，你也可以启用重定向:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(<span class="string">'http://github.com'</span>, allow_redirects=<span class="keyword">True</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.url</div><div class="line"><span class="string">'https://github.com/'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.history</div><div class="line">[&lt;Response [<span class="number">301</span>]&gt;]</div></pre></td></tr></table></figure></p>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>你可以告诉<code>requests</code>在经过以 <code>timeout</code> 参数设定的秒数时间之后停止等待响应:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'http://github.com'</span>, timeout=<span class="number">0.001</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">requests.exceptions.Timeout: HTTPConnectionPool(host=<span class="string">'github.com'</span>, port=<span class="number">80</span>): Request timed out. (timeout=<span class="number">0.001</span>)</div></pre></td></tr></table></figure></p>
<p><code>timeout</code> 仅对连接过程有效，与响应体的下载无关。</p>
<h3 id="错误与异常"><a href="#错误与异常" class="headerlink" title="错误与异常"></a>错误与异常</h3><p>遇到网络问题（如：DNS查询失败、拒绝连接等）时，<code>Requests</code>会抛出一个<code>ConnectionError</code> 异常。<br>遇到罕见的无效HTTP响应时，<code>Requests</code>则会抛出一个 <code>HTTPError</code> 异常。<br>若请求超时，则抛出一个 <code>Timeout</code> 异常。<br>若请求超过了设定的最大重定向次数，则会抛出一个 <code>TooManyRedirects</code> 异常。<br>所有<code>Requests</code>显式抛出的异常都继承自<code>requests.exceptions.RequestException</code> 。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;使用pip进行安装&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
    
    </summary>
    
      <category term="python" scheme="http://nummy.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://nummy.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB数据库备份与恢复</title>
    <link href="http://nummy.github.io/2016/02/28/backstoremongo/"/>
    <id>http://nummy.github.io/2016/02/28/backstoremongo/</id>
    <published>2016-02-28T13:34:45.000Z</published>
    <updated>2016-02-29T06:36:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用mongodump进行数据库备份实际上是通过一次查询当前服务器快照，并将快照存进磁盘中，因此实际上并不是实时备份，因为获取快照之后，服务器还会有数据写入。</p>
<h3 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h3><p>命令格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongodump -h host -d database -o storepath</div></pre></td></tr></table></figure></p>
<p>还可以使用以下命令获取帮助信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongodump --help</div></pre></td></tr></table></figure></p>
<h3 id="恢复数据库"><a href="#恢复数据库" class="headerlink" title="恢复数据库"></a>恢复数据库</h3><p>使用以下命令进行恢复<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongostore -h host -d database --directoryperdb</div></pre></td></tr></table></figure></p>
<p>还可以使用以下命令获取帮助信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongostore --help</div></pre></td></tr></table></figure></p>
<h3 id="备份集合"><a href="#备份集合" class="headerlink" title="备份集合"></a>备份集合</h3><p>使用<code>mongoexport</code>命令备份集合:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongoexport -h host -d database -c collection -o backstore_filename</div></pre></td></tr></table></figure></p>
<p>使用<code>mongoimport --help</code>获取帮助信息</p>
<h3 id="恢复集合"><a href="#恢复集合" class="headerlink" title="恢复集合"></a>恢复集合</h3><p>使用<code>mongoimport</code>命令恢复集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongoimport -h host -d database -c collectionname --file filename</div></pre></td></tr></table></figure></p>
<p>使用<code>mongoimport --help</code>命令获取帮助信息</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用mongodump进行数据库备份实际上是通过一次查询当前服务器快照，并将快照存进磁盘中，因此实际上并不是实时备份，因为获取快照之后，服务器还会有数据写入。&lt;/p&gt;
&lt;h3 id=&quot;备份数据库&quot;&gt;&lt;a href=&quot;#备份数据库&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="mongodb" scheme="http://nummy.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://nummy.github.io/tags/mongodb/"/>
    
      <category term="database" scheme="http://nummy.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>使用MongoDB命令连接远程数据库</title>
    <link href="http://nummy.github.io/2016/02/28/connectmongo/"/>
    <id>http://nummy.github.io/2016/02/28/connectmongo/</id>
    <published>2016-02-28T11:41:26.000Z</published>
    <updated>2016-02-29T03:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>连接命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongo remote_host:port/database -u user -p password</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;连接命令如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;
    
    </summary>
    
      <category term="mongodb" scheme="http://nummy.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://nummy.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>使用itertools模块实现Python函数式编程</title>
    <link href="http://nummy.github.io/2016/02/25/itertools/"/>
    <id>http://nummy.github.io/2016/02/25/itertools/</id>
    <published>2016-02-25T06:42:16.000Z</published>
    <updated>2016-02-25T06:54:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>itertools提供的函数是受函数式编程语言中类似特性的启发，其目的是保证快速，并且高效的使用内存，而且可以联接在一起表述更为复杂的基于迭代的算法。</p>
<p>与使用列表的算法相比，基于迭代器的算法可以提供更好的内存使用特性。在真正需要数据之前，并不从迭代器生成数据，由于这个原因，不需要将所有数据都同时存储在内存中。这种懒处理模型可以减少内存的使用，相应的可以减少交换以及大数据集的其他副作用，从而改善性能。</p>
<h3 id="合并和分解迭代器"><a href="#合并和分解迭代器" class="headerlink" title="合并和分解迭代器"></a>合并和分解迭代器</h3><p><code>chain()</code>函数取多个迭代器作为参数，最后返回一个迭代器，它能生成所有输入迭代器的内容，就好像这些迭代器来自一个迭代器一样。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools improt *</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> chain([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]):</div><div class="line">    <span class="keyword">print</span> i,</div><div class="line"><span class="keyword">print</span></div></pre></td></tr></table></figure></p>
<p>结果将输出<code>1 2 3 4 5 6</code>。利用<code>chain()</code>可以轻松处理多个序列而不必构造一个大的列表。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;itertools提供的函数是受函数式编程语言中类似特性的启发，其目的是保证快速，并且高效的使用内存，而且可以联接在一起表述更为复杂的基于迭代的算法。&lt;/p&gt;
&lt;p&gt;与使用列表的算法相比，基于迭代器的算法可以提供更好的内存使用特性。在真正需要数据之前，并不从迭代器生成数据，
    
    </summary>
    
      <category term="python" scheme="http://nummy.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://nummy.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python操作Solr</title>
    <link href="http://nummy.github.io/2016/02/25/pysolr/"/>
    <id>http://nummy.github.io/2016/02/25/pysolr/</id>
    <published>2016-02-25T06:09:38.000Z</published>
    <updated>2016-02-25T06:31:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Solr是什么？"><a href="#Solr是什么？" class="headerlink" title="Solr是什么？"></a><code>Solr</code>是什么？</h3><p><code>Solr</code>是一个开源的企业级搜索服务器，底层使用易于扩展和修改的<code>Java</code>来实现。服务器通信使用标准的<code>HTTP</code>和<code>XML</code>，所以如果使用<code>Solr</code> 了解<code>Java</code> 技术会有用却不是必须的要求。</p>
<p><code>Solr</code> 主要特性有：强大的全文检索功能，高亮显示检索结果，动态集群，数据库接口和电子文档（Word ，PDF 等）的处理。而且<code>Solr</code> 具有高度的可扩展，支持分布搜索和索引的复制。</p>
<h3 id="Solr的Python库pysolr"><a href="#Solr的Python库pysolr" class="headerlink" title="Solr的Python库pysolr"></a>Solr的Python库pysolr</h3><p>pysolr是一个对Solr服务进行了封装的Python库，它提供了一个执行solr查询服务的接口。</p>
<p>它支持solr的以下几种操作：</p>
<ul>
<li>基本的查询、修改、删除操作</li>
<li>索引优化</li>
<li>超时支持</li>
</ul>
<h3 id="pysolr的基本用法"><a href="#pysolr的基本用法" class="headerlink" title="pysolr的基本用法"></a>pysolr的基本用法</h3><p>通过一个例子来展示其基本用法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pysolr</div><div class="line"></div><div class="line"><span class="comment"># 创建一个solr实例，timeout为可选参数</span></div><div class="line">solr = pysolr.Solr(<span class="string">'http://localhost:8983/solr/'</span>, timeout=<span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="comment"># 添加数据</span></div><div class="line">solr.add([</div><div class="line">    &#123;</div><div class="line">        <span class="string">"id"</span>: <span class="string">"doc_1"</span>,</div><div class="line">        <span class="string">"title"</span>: <span class="string">"A test document"</span>,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="string">"id"</span>: <span class="string">"doc_2"</span>,</div><div class="line">        <span class="string">"title"</span>: <span class="string">"The Banana: Tasty or Dangerous?"</span>,</div><div class="line">    &#125;,</div><div class="line">])</div><div class="line"></div><div class="line"><span class="comment"># 优化索引，以加快查询速度</span></div><div class="line">solr.optimize()</div><div class="line"></div><div class="line"><span class="comment"># 进行查询</span></div><div class="line">results = solr.search(<span class="string">'bananas'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 存储结果保存在results中 </span></div><div class="line">print(<span class="string">"Saw &#123;0&#125; result(s)."</span>.format(len(results)))</div><div class="line"></div><div class="line"><span class="comment"># 循环获取结果</span></div><div class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</div><div class="line">    print(<span class="string">"The title is '&#123;0&#125;'."</span>.format(result[<span class="string">'title'</span>]))</div><div class="line"></div><div class="line"><span class="comment"># 更加高级的查询</span></div><div class="line">results = solr.search(<span class="string">'bananas'</span>, **&#123;</div><div class="line">    <span class="string">'hl'</span>: <span class="string">'true'</span>,</div><div class="line">    <span class="string">'hl.fragsize'</span>: <span class="number">10</span>,</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment"># 也可以进行模糊查询</span></div><div class="line">similar = solr.more_like_this(q=<span class="string">'id:doc_2'</span>, mltfl=<span class="string">'text'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 删除文档</span></div><div class="line">solr.delete(id=<span class="string">'doc_1'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 删除所有文档</span></div><div class="line">solr.delete(q=<span class="string">'*:*'</span>)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Solr是什么？&quot;&gt;&lt;a href=&quot;#Solr是什么？&quot; class=&quot;headerlink&quot; title=&quot;Solr是什么？&quot;&gt;&lt;/a&gt;&lt;code&gt;Solr&lt;/code&gt;是什么？&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Solr&lt;/code&gt;是一个开源的企业级搜索服务器，底
    
    </summary>
    
      <category term="python" scheme="http://nummy.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://nummy.github.io/tags/python/"/>
    
  </entry>
  
</feed>
