<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="description"><meta name="viewport" content="width=device-width, initial-scale=1"><title>iterable vs. iterator vs. generator · Nummy</title><link rel="short icon" href="/favicon.ico"><!-- font--><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,600|Roboto Mono"><!-- icon--><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><!-- theme style--><link rel="stylesheet" href="/css/style.css"></head><body><div id="main"><header><a href="/." class="logo">Nummy</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/categories/" target="_self">Categories</a></li><li class="nav-link"><a href="/tags/" target="_self">Tags</a></li><li class="nav-link"><a href="/about/" target="_self">About</a></li></ul></header><section id="container"><article class="post"><h1 class="post-title">iterable vs. iterator vs. generator</h1><span class="post-time">Mar 23, 2016</span><div id="sidebar" class="post-sidebar"><h3 class="heading">Directory</h3><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#容器（container"><span class="toc-text">容器（container)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可迭代对象"><span class="toc-text">可迭代对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器-Iterators"><span class="toc-text">迭代器(Iterators)</span></a></li></ol></div><div class="post-content"><blockquote>
<p>版权所有，如需转载，请联系译者<br>原文地址<a href="http:
//nvie.com/posts/iterators-vs-generators/" target="_blank" rel="external">http://nvie.com/posts/iterators-vs-generators/</a></p>
</blockquote>
<p>在使用Python的过程中，很容易混淆如下几个关联的概念：</p>
<ul>
<li>容器(container)</li>
<li>可迭代对象(Iterable)</li>
<li>迭代器(Iterator)</li>
<li>生成器(generator)</li>
<li>生成器表达式</li>
<li>{list, set, dict} 解析式</li>
</ul>
<p>它们之间的关系如下表所示：<br><img src="http://upload-images.jianshu.io/upload_images/1677721-ff5b5bb12c51e4c3.png" alt=""></p>
<h3 id="容器（container"><a href="#容器（container" class="headerlink" title="容器（container)"></a>容器（container)</h3><p>容器是用来储存元素的一种数据结构，它支持隶属测试，容器将所有数据保存在内存中，在Python中典型的容器有：</p>
<ul>
<li>list， deque, …</li>
<li>set，frozesets，…</li>
<li>dict, defaultdict, OrderedDict, Counter, …</li>
<li>tuple, namedtuple, …</li>
<li>str</li>
</ul>
<p>容器相对来说很好理解，因为你可以把它当成生活中的箱子、房子、船等等。<br>一般的，通过判断一个对象是否包含某个元素来确定它是否为一个容器。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">1</span> <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]       <span class="comment"># lists</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">4</span> <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">1</span> <span class="keyword">in</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;       <span class="comment"># sets</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">4</span> <span class="keyword">not</span> <span class="keyword">in</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">1</span> <span class="keyword">in</span> (<span class="number">12</span>,<span class="number">3</span>)        <span class="comment"># tuples</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">4</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>字典容器通过检查是否包含键来进行判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>:<span class="string">"foo"</span>, <span class="number">2</span>:<span class="string">"bar"</span>, <span class="number">3</span>:<span class="string">"qux"</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">1</span> <span class="keyword">in</span> d</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">4</span> <span class="keyword">not</span> <span class="keyword">in</span> d</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="string">"foo"</span> <span class="keyword">not</span> <span class="keyword">in</span> d</div></pre></td></tr></table></figure>
<p>字符串通过检查是否包含某个子 串来判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s =<span class="string">"foobar"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="string">"b"</span> <span class="keyword">in</span> s</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="string">"x"</span> <span class="keyword">not</span> <span class="keyword">in</span> s</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="string">"foo"</span> <span class="keyword">in</span> s</div></pre></td></tr></table></figure>
<blockquote>
<p> <strong>注意</strong>：并非所有的容器都是可迭代对象。</p>
</blockquote>
<h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><p>正如前面所提到的，大部分容器都是可迭代的，但是还有其他一些对象也可以迭代，例如，文件对象以及管道对象等等，容器一般来说存储的元素是有限的，同样的，可迭代对象也可以用来表示一个包含有限元素的数据结构。</p>
<p>可迭代对象可以为任意对象，不一定非得是基本数据结构，只要这个对象可以返回一个<strong>iterator</strong>。听起来可能有点费解，但是可迭代对象与迭代器之间有一个显著的区别。先看下面的例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x = [1,2,3]</div><div class="line">&gt;&gt;&gt; y = iter(x）</div><div class="line">&gt;&gt;&gt; z = iter(x)</div><div class="line">&gt;&gt;&gt; next(y)</div><div class="line">1</div><div class="line">&gt;&gt;&gt; next(y)</div><div class="line">2</div><div class="line">&gt;&gt;&gt; next(z)</div><div class="line">1</div><div class="line">&gt;&gt;&gt; type(x)</div><div class="line">&lt;class 'list'&gt;</div><div class="line">&gt;&gt;&gt; type(y)</div><div class="line">&lt;class 'list_iterator'&gt;</div></pre></td></tr></table></figure></p>
<p>在这里，x是可迭代对象，而y和z都是迭代器，它们从可迭代对象x中获取值。</p>
<blockquote>
<p><strong>注意</strong>：可迭代的类中，一般实现以下两个方法，<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当我们运行以下代码的时候:</div><div class="line">```Python</div><div class="line">x = [1,2,3]</div><div class="line">for elem in x:</div><div class="line">     ...</div></pre></td></tr></table></figure></p>
</blockquote>
<p>实际调用过程如下：<br><img src="http://upload-images.jianshu.io/upload_images/1677721-9453ca206b60475d.png" alt=""><br>当我们反向编译这段代Python码的时候，可以发现它显示调用了 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">```Python</div><div class="line">&gt;&gt;&gt; import dis</div><div class="line">&gt;&gt;&gt; x = [1, 2, 3]</div><div class="line">&gt;&gt;&gt; dis.dis(&apos;for _ in x: pass&apos;) </div><div class="line">1     0 SETUP_LOOP                     14 (to 17) </div><div class="line">       3 LOAD_NAME                       0 (x) </div><div class="line">       6 GET_ITER </div><div class="line"> &gt;&gt; 7 FOR_ITER                            6 (to 16) </div><div class="line">       10 STORE_NAME                    1 (_) </div><div class="line">       13 JUMP_ABSOLUTE               7 </div><div class="line"> &gt;&gt; 16 POP_BLOCK </div><div class="line"> &gt;&gt; 17 LOAD_CONST                    0 (None) </div><div class="line">       20 RETURN_VALUE</div></pre></td></tr></table></figure></p>
<h3 id="迭代器-Iterators"><a href="#迭代器-Iterators" class="headerlink" title="迭代器(Iterators)"></a>迭代器(Iterators)</h3><p>那么什么是迭代器呢？任何具有<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">所以迭代器本质上是一个产生值的工厂，每次向迭代器请求下一个值，迭代器都会进行计算出相应的值并返回。</div><div class="line"></div><div class="line">迭代器的例子很多，例如，所有```itertools ```模块中的函数都会返回一个迭代器，有的还可以产生无穷的序列。</div><div class="line">```Python</div><div class="line">&gt;&gt;&gt; from itertools import count</div><div class="line">&gt;&gt;&gt; counter = count(start=13)</div><div class="line">&gt;&gt;&gt; next(counter)</div><div class="line">13</div><div class="line">&gt;&gt;&gt; next（counter)</div><div class="line">14</div></pre></td></tr></table></figure></p>
<p>有的函数根据有限序列中生成无限序列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from itertools import cycle</div><div class="line">&gt;&gt;&gt; colors = cycle([&quot;red&quot;,&quot;white&quot;,&quot;blue&quot;])</div><div class="line">&gt;&gt;&gt; next(colors)</div><div class="line">&quot;red&quot;</div><div class="line">&gt;&gt;&gt; next(colors）</div><div class="line">&quot;white&quot;</div><div class="line">&gt;&gt;&gt; next(colors)</div><div class="line">&quot;blue&quot;</div><div class="line">&gt;&gt;&gt; next(colors)</div><div class="line">&quot;red&quot;</div></pre></td></tr></table></figure></p>
<p>有的函数根据无限序列中生成有限序列：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>colors = cycle([<span class="string">'red'</span>, <span class="string">'white'</span>, <span class="string">'blue'</span>])               <span class="comment"># infinite</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>limited = islice(colors, <span class="number">0</span>, <span class="number">4</span>)                          <span class="comment"># finite</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> limited:                                            <span class="comment"># so safe to use for-loop on</span></div><div class="line"><span class="meta">... </span>           print(x)</div><div class="line">red</div><div class="line">white</div><div class="line">blue</div><div class="line">red</div></pre></td></tr></table></figure></p>
<p>为了更好的理解迭代器的内部结构，我们先来定义一个生成斐波拉契数的迭代器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">fib</span>:</span></div><div class="line"><span class="meta">... </span>            <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>                  self.prev = <span class="number">0</span></div><div class="line"><span class="meta">... </span>                  self.curr = <span class="number">1</span></div><div class="line"><span class="meta">... </span></div><div class="line"><span class="meta">... </span>            <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>                  <span class="keyword">return</span> self</div><div class="line"><span class="meta">... </span></div><div class="line"><span class="meta">... </span>            <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>                  value = self.curr</div><div class="line"><span class="meta">... </span>                  self.curr += self.prev</div><div class="line"><span class="meta">... </span>                  self.prev = value</div><div class="line"><span class="meta">... </span>                  <span class="keyword">return</span> value</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = fib()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(islice(f, <span class="number">0</span>, <span class="number">10</span>))</div><div class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>]</div></pre></td></tr></table></figure></p>
<p>注意这个类既是可迭代的 （因为具有<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">迭代器内部状态保存在当前实例对象的```prev```以及```cur```属性中，在下一次调用中将使用这两个属性。每次调用```next()```方法都会执行以下两步操作：</div><div class="line"></div><div class="line">1. 修改状态，以便下次调用```next()```方法</div><div class="line">2. 计算当前调用的结果</div><div class="line"></div><div class="line">&gt; **比喻**：从外部来看，迭代器就像政府工作人员一样，没人找他办事的时候（请求值），工作人员就闲着，当有人来找他的时候（请求值），工作人员就会忙一会，把请求的东西找出来交给请求的人。忙完之后，又没事了，继续闲着。</div><div class="line"></div><div class="line">### 生成器</div><div class="line"></div><div class="line">生成器其实就是一种特殊的迭代器。它使一种更为高级、更为优雅的迭代器。</div><div class="line">使用生成器让我们可以以一种更加简洁的语法来定义迭代器。</div><div class="line">让我们先明确以下两点：</div><div class="line">- 任意生成器都是迭代器（反过来不成立）</div><div class="line">- 任意生成器，都是一个可以延迟创建值的工厂</div><div class="line"></div><div class="line">下面也是一个生成斐波那契序列的工厂函数，不过是以生成器的方式编写的：</div><div class="line">```Python</div><div class="line">&gt;&gt;&gt; def fib():</div><div class="line">...            prev, curr = 0, 1</div><div class="line">...            while True:</div><div class="line">...                     yield curr</div><div class="line">...                     prev, curr = curr, prev + curr</div><div class="line">...</div><div class="line">&gt;&gt;&gt; f = fib()</div><div class="line">&gt;&gt;&gt; list(islice(f, 0, 10))</div><div class="line">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</div></pre></td></tr></table></figure></p>
<p>上面的代码是不是既优雅又简洁？注意其中用到的魔法关键字<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">yield</span></div></pre></td></tr></table></figure></p>
<p>一起来剖析下上面的代码：首先，fib其实是一个很普通的函数，但是函数中没有<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当调用```f = fib()```时，生成器被实例化并返回，这时并不会执行任何代码，生成器处于空闲状态，注意这里```prev, curr = 0, 1 ```并未执行。</div><div class="line"></div><div class="line">然后这个生成器被包含在```isslice()```中，而这又是一个迭代器，所以还是没有执行上面的代码。</div><div class="line"></div><div class="line">然后这个迭代器又被包含在```list()```中，它会根据传进来的参数生成一个列表。所以它首先对```isslice()```对象调用```next()```方法，```isslice()```对象又会对实例```f```调用```next()```。</div><div class="line">我们来看其中的一步操作，在第一次调用中，会执行```prev, curr = 0, 1```, 然后进入while循环，当遇到```yield curr```的时候，返回当前curr值，然后又进入空闲状态。</div><div class="line">生成的值传递给外层的```isslice()```，也相应生成一个值，然后传递给外层的```list()```，外层的list将这个值1添加到列表中。</div><div class="line">然后继续执行后面的九步操作，每步操作的流程都是一样的。</div><div class="line"></div><div class="line">然后执行到底11步的时候，```isslice()```对象就会抛出```StopIteration```异常，意味着已经到达末尾了。注意生成器不会接收到第11次```next()```请求，后面会被垃圾回收掉。</div><div class="line"></div><div class="line">### 生成器的类型</div><div class="line"></div><div class="line">在Python中两种类型的生成器：**生成器函数**以及**生成器表达式**。生成器函数就是包含```yield```参数的函数。生成器表达式与列表解析式类似。</div><div class="line">假设使用如下语法创建一个列表：</div><div class="line">```Python</div><div class="line">&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5, 6]</div><div class="line">&gt;&gt;&gt; [x * x for x in numbers]</div><div class="line">[1, 4, 9, 16, 25, 36]</div></pre></td></tr></table></figure></p>
<p>使用set解析式也可以达到同样的目的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &#123;x * x for x in numbers&#125;&#123;1, 4, 36, 9, 16, 25&#125;</div></pre></td></tr></table></figure></p>
<p>或者dict解析式:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x: x * x <span class="keyword">for</span> x <span class="keyword">in</span> numbers&#125;</div><div class="line">&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">5</span>: <span class="number">25</span>, <span class="number">6</span>: <span class="number">36</span>&#125;</div></pre></td></tr></table></figure></p>
<p>还可以使用生成器表达式:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lazy_squares = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> numbers)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lazy_squares</div><div class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x10d1f5510</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(lazy_squares)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(lazy_squares)</div><div class="line">[<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>]</div></pre></td></tr></table></figure></p>
<p>注意我们第一次调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 总结</div><div class="line"></div><div class="line">生成器是Python中一种非常强大的特性，它让我们能够编写更加简洁的代码，同时也更加节省内存，使用CPU也更加高效。</div><div class="line">使用生成器的小提示：在你的代码中找到与下面代码类似的地方：</div><div class="line">```Python</div><div class="line">def something(): </div><div class="line">      result = [] </div><div class="line">      for ... in ...: </div><div class="line">           result.append(x) </div><div class="line">      return result</div></pre></td></tr></table></figure></p>
<p>用以下代码进行替换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">iter_something</span><span class="params">()</span>:</span> </div><div class="line">      <span class="keyword">for</span> ... <span class="keyword">in</span> ...: </div><div class="line">            <span class="keyword">yield</span> x</div></pre></td></tr></table></figure></p>
</div></article><div class="tags"><a href="/tags/python/">python</a></div><div class="paginator"><a href="/2016/08/17/runit-quick-tutorial/" class="prev"><i class="iconfont icon-left"></i><span> Prev</span></a><a href="/2016/03/16/zookeeper/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div><section id="comments"><div data-thread-key="http://nummy.github.io/2016/03/23/iterator-vs-generator/index.html" data-title="iterable vs. iterator vs. generator" data-url="http://nummy.github.io/2016/03/23/iterator-vs-generator/index.html" class="ds-thread"></div><script type="text/javascript">var duoshuoQuery = {short_name: "nummy" };
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></section></section><footer><div class="copyright"><p>&copy;2016<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Nummy Lee</span></p><p class="theme">Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div></body><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></html>