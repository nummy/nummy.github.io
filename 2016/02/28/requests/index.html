<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="description"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Python Requests 快速入门 · Nummy</title><link rel="short icon" href="/favicon.ico"><!-- font--><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,600|Roboto Mono"><!-- icon--><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><!-- theme style--><link rel="stylesheet" href="/css/style.css"><!-- baidu analytics--><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?9e0cbea7d3319c6c94c71dfb93c151b8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- google analytics--><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-74273646-1', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">Nummy</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/categories/" target="_self">Categories</a></li><li class="nav-link"><a href="/tags/" target="_self">Tags</a></li><li class="nav-link"><a href="/about/" target="_self">About</a></li></ul></header><section id="container"><article class="post"><h1 class="post-title">Python Requests 快速入门</h1><span class="post-time">Feb 28, 2016</span><div id="sidebar" class="post-sidebar"><h3 class="heading">Directory</h3><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#安装"><span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发送请求"><span class="toc-text">发送请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为URL传递参数"><span class="toc-text">为URL传递参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应内容"><span class="toc-text">响应内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制响应内容"><span class="toc-text">二进制响应内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON响应内容"><span class="toc-text">JSON响应内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原始响应内容"><span class="toc-text">原始响应内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定制请求头"><span class="toc-text">定制请求头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更加复杂的POST请求"><span class="toc-text">更加复杂的POST请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POST一个文件"><span class="toc-text">POST一个文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应状态码"><span class="toc-text">响应状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应头"><span class="toc-text">响应头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookies"><span class="toc-text">Cookies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重定向与请求历史"><span class="toc-text">重定向与请求历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#超时"><span class="toc-text">超时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误与异常"><span class="toc-text">错误与异常</span></a></li></ol></div><div class="post-content"><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用pip进行安装<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install Requests</div></pre></td></tr></table></figure></p>
<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>使用Requests发送网络请求非常简单，一开始要导入Requests模块:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</div></pre></td></tr></table></figure></p>
<p>然后，尝试获取某个网页。本例子中，我们来获取Github的公共时间线<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)</div></pre></td></tr></table></figure></p>
<p>现在，我们有一个名为 r 的 Response 对象。可以从这个对象中获取所有我们想要的信息。<br>Requests简便的API意味着所有HTTP请求类型都是显而易见的。例如，你可以这样发送一个HTTP POST请求:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(<span class="string">"http://httpbin.org/post"</span>)</div></pre></td></tr></table></figure></p>
<p>漂亮，对吧？那么其他HTTP请求类型：PUT， DELETE， HEAD以及OPTIONS又是如何的呢？都是一样的简单:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.put(<span class="string">"http://httpbin.org/put"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.delete(<span class="string">"http://httpbin.org/delete"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.head(<span class="string">"http://httpbin.org/get"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.options(<span class="string">"http://httpbin.org/get"</span>)</div></pre></td></tr></table></figure></p>
<p>都很不错吧，但这也仅是Requests的冰山一角呢。</p>
<h3 id="为URL传递参数"><a href="#为URL传递参数" class="headerlink" title="为URL传递参数"></a>为URL传递参数</h3><p>你也许经常想为URL的查询字符串(query string)传递某种数据。如果你是手工构建URL，那么数据会以键/值 对的形式置于URL中，跟在一个问号的后面。例如，<code>httpbin.org/get?key=val</code> 。 <code>Requests</code>允许你使用 <code>params</code> 关键字参数，以一个字典来提供这些参数。举例来说，如果你想传递 <code>key1=value1</code> 和 <code>key2=value2</code> 到 <code>httpbin.org/get</code> ，那么你可以使用如下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">"http://httpbin.org/get"</span>, params=payload)</div></pre></td></tr></table></figure></p>
<p>通过打印输出该URL，你能看到URL已被正确编码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> r.url</div><div class="line"><span class="string">u'http://httpbin.org/get?key2=value2&amp;key1=value1'</span></div></pre></td></tr></table></figure></p>
<h3 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h3><p>我们能读取服务器响应的内容。再次以Github时间线为例:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line"><span class="string">'[&#123;"repository":&#123;"open_issues":0,"url":"https://github.com/"...'</span></div></pre></td></tr></table></figure></p>
<p>Requests会自动解码来自服务器的内容。大多数unicode字符集都能被无缝地解码。<br>请求发出后，Requests会基于HTTP头部对响应的编码作出有根据的推测。当你访问r.text 之时，Requests会使用其推测的文本编码。你可以找出Requests使用了什么编码，并且能够使用 r.encoding 属性来改变它:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.encoding</div><div class="line"><span class="string">'utf-8'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.encoding = <span class="string">'ISO-8859-1'</span></div></pre></td></tr></table></figure></p>
<p>如果你改变了编码，每当你访问 r.text ，Request都将会使用 r.encoding 的新值。<br>在你需要的情况下，Requests也可以使用定制的编码。如果你创建了自己的编码，并使用codecs 模块进行注册，你就可以轻松地使用这个解码器名称作为 r.encoding 的值， 然后由Requests来为你处理编码。</p>
<h3 id="二进制响应内容"><a href="#二进制响应内容" class="headerlink" title="二进制响应内容"></a>二进制响应内容</h3><p>你也能以字节的方式访问请求响应体，对于非文本请求:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.content</div><div class="line"><span class="string">b'[&#123;"repository":&#123;"open_issues":0,"url":"https://github.com/...'</span></div></pre></td></tr></table></figure></p>
<p>Requests会自动为你解码 gzip 和 deflate 传输编码的响应数据。<br>例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> StringIO <span class="keyword">import</span> StringIO</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>i = Image.open(StringIO(r.content))</div></pre></td></tr></table></figure></p>
<h3 id="JSON响应内容"><a href="#JSON响应内容" class="headerlink" title="JSON响应内容"></a>JSON响应内容</h3><p>Requests中也有一个内置的JSON解码器，助你处理JSON数据:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://github.com/timeline.json'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.json()</div><div class="line">[&#123;<span class="string">u'repository'</span>: &#123;<span class="string">u'open_issues'</span>: <span class="number">0</span>, <span class="string">u'url'</span>: <span class="string">'https://github.com/...'</span>&#125;]</div></pre></td></tr></table></figure></p>
<p>如果JSON解码失败， r.json 就会抛出一个异常。</p>
<h3 id="原始响应内容"><a href="#原始响应内容" class="headerlink" title="原始响应内容"></a>原始响应内容</h3><p>在罕见的情况下你可能想获取来自服务器的原始套接字响应，那么你可以访问 <code>r.raw</code> 。 如果你确实想这么干，那请你确保在初始请求中设置了 <code>stream=True</code> 。具体的你可以这么做:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://github.com/timeline.json'</span>, stream=<span class="keyword">True</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.raw</div><div class="line">&lt;requests.packages.urllib3.response.HTTPResponse object at <span class="number">0x101194810</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.raw.read(<span class="number">10</span>)</div><div class="line"><span class="string">'\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03'</span></div></pre></td></tr></table></figure></p>
<h3 id="定制请求头"><a href="#定制请求头" class="headerlink" title="定制请求头"></a>定制请求头</h3><p>如果你想为请求添加HTTP头部，只要简单地传递一个 dict 给 headers 参数就可以了。<br>例如，在前一个示例中我们没有指定content-type:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://api.github.com/some/endpoint'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>payload = &#123;<span class="string">'some'</span>: <span class="string">'data'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>headers = &#123;<span class="string">'content-type'</span>: <span class="string">'application/json'</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, data=json.dumps(payload), headers=headers)</div></pre></td></tr></table></figure></p>
<h3 id="更加复杂的POST请求"><a href="#更加复杂的POST请求" class="headerlink" title="更加复杂的POST请求"></a>更加复杂的POST请求</h3><p>通常，你想要发送一些编码为表单形式的数据—非常像一个HTML表单。 要实现这个，只需简单地传递一个字典给 data 参数。你的数据字典 在发出请求时会自动编码为表单形式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(<span class="string">"http://httpbin.org/post"</span>, data=payload)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> r.text</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  <span class="string">"form"</span>: &#123;</div><div class="line">    <span class="string">"key2"</span>: <span class="string">"value2"</span>,</div><div class="line">    <span class="string">"key1"</span>: <span class="string">"value1"</span></div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 string 而不是一个dict ，那么数据会被直接发布出去。<br>例如，Github API v3接受编码为JSON的POST/PATCH数据:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://api.github.com/some/endpoint'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>payload = &#123;<span class="string">'some'</span>: <span class="string">'data'</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, data=json.dumps(payload))</div></pre></td></tr></table></figure>
<h3 id="POST一个文件"><a href="#POST一个文件" class="headerlink" title="POST一个文件"></a>POST一个文件</h3><p>Requests使得上传文件变得很简单:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">'file'</span>: open(<span class="string">'report.xls'</span>, <span class="string">'rb'</span>)&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  <span class="string">"files"</span>: &#123;</div><div class="line">    <span class="string">"file"</span>: <span class="string">"&lt;censored...binary...data&gt;"</span></div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以显式地设置文件名:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">'file'</span>: (<span class="string">'report.xls'</span>, open(<span class="string">'report.xls'</span>, <span class="string">'rb'</span>))&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  <span class="string">"files"</span>: &#123;</div><div class="line">    <span class="string">"file"</span>: <span class="string">"&lt;censored...binary...data&gt;"</span></div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你想，你也可以发送作为文件来接收的字符串:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/post'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>files = &#123;<span class="string">'file'</span>: (<span class="string">'report.csv'</span>, <span class="string">'some,data,to,send\nanother,row,to,send\n'</span>)&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, files=files)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  <span class="string">"files"</span>: &#123;</div><div class="line">    <span class="string">"file"</span>: <span class="string">"some,data,to,send\\nanother,row,to,send\\n"</span></div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><p>我们可以检测响应状态码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://httpbin.org/get'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">200</span></div></pre></td></tr></table></figure></p>
<p>为方便引用，Requests还附带了一个内置的状态码查询对象:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code == requests.codes.ok</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure></p>
<p>如果发送了一个失败请求(非200响应)，我们可以通过 Response.raise_for_status() 来抛出异常:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>bad_r = requests.get(<span class="string">'http://httpbin.org/status/404'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bad_r.status_code</div><div class="line"><span class="number">404</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bad_r.raise_for_status()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"requests/models.py"</span>, line <span class="number">832</span>, <span class="keyword">in</span> raise_for_status</div><div class="line">    <span class="keyword">raise</span> http_error</div><div class="line">requests.exceptions.HTTPError: <span class="number">404</span> Client Error</div></pre></td></tr></table></figure></p>
<p>但是，由于我们的例子中 r 的 status_code 是 200 ，当我们调用 raise_for_status() 时，得到的是:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.raise_for_status()</div><div class="line"><span class="keyword">None</span></div></pre></td></tr></table></figure></p>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>我们可以查看以一个Python字典形式展示的服务器响应头:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers</div><div class="line">&#123;</div><div class="line">    <span class="string">'status'</span>: <span class="string">'200 OK'</span>,</div><div class="line">    <span class="string">'content-encoding'</span>: <span class="string">'gzip'</span>,</div><div class="line">    <span class="string">'transfer-encoding'</span>: <span class="string">'chunked'</span>,</div><div class="line">    <span class="string">'connection'</span>: <span class="string">'close'</span>,</div><div class="line">    <span class="string">'server'</span>: <span class="string">'nginx/1.0.4'</span>,</div><div class="line">    <span class="string">'x-runtime'</span>: <span class="string">'148ms'</span>,</div><div class="line">    <span class="string">'etag'</span>: <span class="string">'"e1ca502697e5c9317743dc078f67693f"'</span>,</div><div class="line">    <span class="string">'content-type'</span>: <span class="string">'application/json; charset=utf-8'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是这个字典比较特殊：它是仅为HTTP头部而生的。根据 RFC 2616 ， HTTP头部是大小写不敏感的。<br>因此，我们可以使用任意大写形式来访问这些响应头字段:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers[<span class="string">'Content-Type'</span>]</div><div class="line"><span class="string">'application/json; charset=utf-8'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers.get(<span class="string">'content-type'</span>)</div><div class="line"><span class="string">'application/json; charset=utf-8'</span></div></pre></td></tr></table></figure></p>
<p>如果某个响应头字段不存在，那么它的默认值为 None<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers[<span class="string">'X-Random'</span>]</div><div class="line"><span class="keyword">None</span></div></pre></td></tr></table></figure></p>
<h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>如果某个响应中包含一些Cookie，你可以快速访问它们:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://example.com/some/cookie/setting/url'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.cookies[<span class="string">'example_cookie_name'</span>]</div><div class="line"><span class="string">'example_cookie_value'</span></div></pre></td></tr></table></figure></p>
<p>要想发送你的cookies到服务器，可以使用 cookies 参数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/cookies'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>cookies = dict(cookies_are=<span class="string">'working'</span>)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url, cookies=cookies)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line"><span class="string">'&#123;"cookies": &#123;"cookies_are": "working"&#125;&#125;'</span></div></pre></td></tr></table></figure></p>
<h3 id="重定向与请求历史"><a href="#重定向与请求历史" class="headerlink" title="重定向与请求历史"></a>重定向与请求历史</h3><p>使用<code>GET</code>或<code>OPTIONS</code>时，<code>Requests</code>会自动处理位置重定向。<br><code>Github</code>将所有的<code>HTTP</code>请求重定向到<code>HTTPS</code>。可以使用响应对象的 <code>history</code> 方法来追踪重定向。 我们来看看<code>Github</code>做了什么:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://github.com'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.url</div><div class="line"><span class="string">'https://github.com/'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">200</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.history</div><div class="line">[&lt;Response [<span class="number">301</span>]&gt;]</div></pre></td></tr></table></figure></p>
<p><code>Response.history</code> 是一个<code>:class:Request</code> 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。<br>如果你使用的是GET或OPTIONS，那么你可以通过<code>allow_redirects</code>参数禁用重定向处理:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://github.com'</span>, allow_redirects=<span class="keyword">False</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">301</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.history</div><div class="line">[]</div></pre></td></tr></table></figure></p>
<p>如果你使用的是POST，PUT，PATCH，DELETE或HEAD，你也可以启用重定向:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(<span class="string">'http://github.com'</span>, allow_redirects=<span class="keyword">True</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.url</div><div class="line"><span class="string">'https://github.com/'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.history</div><div class="line">[&lt;Response [<span class="number">301</span>]&gt;]</div></pre></td></tr></table></figure></p>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>你可以告诉<code>requests</code>在经过以 <code>timeout</code> 参数设定的秒数时间之后停止等待响应:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>requests.get(<span class="string">'http://github.com'</span>, timeout=<span class="number">0.001</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">requests.exceptions.Timeout: HTTPConnectionPool(host=<span class="string">'github.com'</span>, port=<span class="number">80</span>): Request timed out. (timeout=<span class="number">0.001</span>)</div></pre></td></tr></table></figure></p>
<p><code>timeout</code> 仅对连接过程有效，与响应体的下载无关。</p>
<h3 id="错误与异常"><a href="#错误与异常" class="headerlink" title="错误与异常"></a>错误与异常</h3><p>遇到网络问题（如：DNS查询失败、拒绝连接等）时，<code>Requests</code>会抛出一个<code>ConnectionError</code> 异常。<br>遇到罕见的无效HTTP响应时，<code>Requests</code>则会抛出一个 <code>HTTPError</code> 异常。<br>若请求超时，则抛出一个 <code>Timeout</code> 异常。<br>若请求超过了设定的最大重定向次数，则会抛出一个 <code>TooManyRedirects</code> 异常。<br>所有<code>Requests</code>显式抛出的异常都继承自<code>requests.exceptions.RequestException</code> 。</p>
</div></article><div class="tags"><a href="/tags/python/">python</a></div><div class="paginator"><a href="/2016/03/02/pycharm/" class="prev"><i class="iconfont icon-left"></i><span> Prev</span></a><a href="/2016/02/28/backstoremongo/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div><section id="comments"><div id="disqus_thread"></div></section><script type="text/javascript">(function() {
var d = document, s = d.createElement('script');

s.src = '//ahonn.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script></section><footer><div class="copyright"><p>&copy;2016<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Nummy Lee</span></p><p class="theme">Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div></body><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></html>